<!doctype html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Numerical Computing and Scientific Simulation</title>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/reveal.js@4.5.0/dist/reset.css">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/reveal.js@4.5.0/dist/reveal.css">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/reveal.js@4.5.0/dist/theme/night.css">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/reveal.js@4.5.0/plugin/highlight/monokai.css">
    <style>
        :root {
            --accent-blue: #61afef;
            --accent-green: #98c379;
            --accent-yellow: #e5c07b;
            --accent-red: #e06c75;
            --accent-purple: #c678dd;
            --accent-cyan: #56b6c2;
        }
        .reveal h1, .reveal h2, .reveal h3 { text-transform: none; }
        .reveal h1 { font-size: 2.2em; }
        .reveal h2 { font-size: 1.6em; }
        .reveal h3 { font-size: 1.3em; }
        .reveal blockquote {
            font-style: italic;
            background: rgba(255,255,255,0.05);
            padding: 20px 30px;
            border-left: 4px solid #42affa;
            width: 90%;
            margin: 0 auto;
            border-radius: 0 8px 8px 0;
        }
        .reveal .slides section { text-align: left; }
        .reveal ul { display: block; }
        .reveal li { margin: 0.5em 0; font-size: 0.85em; }
        .center-text { text-align: center; }
        .highlight-box {
            background: rgba(66, 175, 250, 0.15);
            padding: 15px 20px;
            border-radius: 8px;
            margin: 15px 0;
            border: 1px solid rgba(66, 175, 250, 0.3);
        }
        .warning-box {
            background: rgba(224, 108, 117, 0.15);
            padding: 15px 20px;
            border-radius: 8px;
            margin: 15px 0;
            border: 1px solid rgba(224, 108, 117, 0.3);
        }
        .success-box {
            background: rgba(152, 195, 121, 0.15);
            padding: 15px 20px;
            border-radius: 8px;
            margin: 15px 0;
            border: 1px solid rgba(152, 195, 121, 0.3);
        }
        .principle-box {
            background: rgba(198, 120, 221, 0.15);
            padding: 15px 20px;
            border-radius: 8px;
            margin: 15px 0;
            border: 1px solid rgba(198, 120, 221, 0.3);
        }
        .small-text { font-size: 0.75em; }
        .tiny-text { font-size: 0.65em; }
        pre code { font-size: 0.65em !important; line-height: 1.4 !important; }
        .reveal pre { width: 100%; box-shadow: 0 5px 15px rgba(0,0,0,0.3); }
        .two-column { display: flex; gap: 30px; align-items: flex-start; }
        .two-column > div { flex: 1; }
        .three-column { display: flex; gap: 20px; }
        .three-column > div { flex: 1; }
        .equation-box {
            background: rgba(255,255,255,0.08);
            padding: 20px;
            border-radius: 8px;
            text-align: center;
            margin: 15px 0;
            font-size: 1.1em;
        }
        table.comparison {
            width: 100%;
            border-collapse: collapse;
            font-size: 0.8em;
        }
        table.comparison th, table.comparison td {
            padding: 12px;
            border: 1px solid rgba(255,255,255,0.2);
        }
        table.comparison th {
            background: rgba(66, 175, 250, 0.2);
        }
        .bowtie-diagram {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 10px;
            margin: 20px 0;
        }
        .bowtie-box {
            padding: 15px 25px;
            border-radius: 8px;
            text-align: center;
            font-weight: bold;
        }
        .bowtie-arrow {
            font-size: 2em;
            color: #888;
        }
        .stencil-grid {
            display: inline-grid;
            grid-template-columns: repeat(3, 55px);
            gap: 4px;
        }
        .stencil-cell {
            width: 55px;
            height: 35px;
            border: 2px solid #444;
            border-radius: 4px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 0.55em;
        }
        .stencil-active { background: rgba(97, 175, 239, 0.5); border-color: #61afef; }
        .stencil-target { background: rgba(152, 195, 121, 0.5); border-color: #98c379; }
        .stencil-inactive { background: rgba(255,255,255,0.05); }
        .slider-container {
            display: flex;
            align-items: center;
            gap: 10px;
            margin: 5px 0;
        }
        .slider-container label {
            min-width: 80px;
            font-size: 0.8em;
        }
        .slider-container input[type="range"] {
            flex: 1;
        }
        .slider-container span {
            min-width: 50px;
            font-size: 0.8em;
            color: var(--accent-blue);
        }
    </style>
</head>
<body>
<div class="reveal">
<div class="slides">

<!-- ============================================ -->
<!-- TITLE SLIDE -->
<!-- ============================================ -->
<section class="center-text">
    <h1>Numerical Computing</h1>
    <h2>and Scientific Simulation</h2>
    <p style="margin-top: 40px; color: #888;">ML for Science - Lecture 5</p>
    <p class="small-text" style="color: #666;">From differential equations to predictions on a computer</p>
</section>

<!-- ============================================ -->
<!-- LEARNING VS INFERENCE -->
<!-- ============================================ -->
<section>
    <section>
        <h2>The Big Picture: Learning vs Inference</h2>
        <div class="bowtie-diagram">
            <div class="bowtie-box" style="background: rgba(97, 175, 239, 0.3);">
                <div>Data</div>
                <div class="tiny-text">(high complexity)</div>
            </div>
            <div class="bowtie-arrow">&rarr;</div>
            <div class="bowtie-box" style="background: rgba(198, 120, 221, 0.3);">
                <div>Model</div>
                <div class="tiny-text">(low complexity)</div>
            </div>
            <div class="bowtie-arrow">&rarr;</div>
            <div class="bowtie-box" style="background: rgba(152, 195, 121, 0.3);">
                <div>Predictions</div>
                <div class="tiny-text">(high complexity)</div>
            </div>
        </div>
        <div class="two-column fragment" style="margin-top: 30px;">
            <div class="highlight-box small-text" style="text-align: center;">
                <strong style="color: var(--accent-blue);">Learning</strong><br>
                Data &rarr; Model<br>
                Compression / Distillation<br>
                Statistical
            </div>
            <div class="success-box small-text" style="text-align: center;">
                <strong style="color: var(--accent-green);">Inference</strong><br>
                Model &rarr; Predictions<br>
                Reconstruction / Generation<br>
                Computational / Recursive
            </div>
        </div>
    </section>

    <section>
        <h2>Today: From Models to Predictions</h2>
        <p>We've seen how to extract models from data (learning/fitting).</p>
        <p class="fragment">Now: <strong>How do we use models to make predictions?</strong></p>
        <div class="fragment principle-box" style="margin-top: 20px;">
            <strong>Key insight:</strong> Both learning and inference require computing, but they're fundamentally different:
            <ul class="small-text" style="margin-top: 10px;">
                <li><strong>Learning:</strong> Compress many observations into simple rules</li>
                <li><strong>Inference:</strong> Apply rules recursively to generate predictions</li>
            </ul>
        </div>
    </section>
</section>

<!-- ============================================ -->
<!-- COMPUTING AS RECURSION -->
<!-- ============================================ -->
<section>
    <section>
        <h2>Computing as Recursive Rule Application</h2>
        <p>The most basic form of computing: <strong>apply a rule repeatedly</strong></p>
        <div class="fragment" style="margin-top: 20px;">
            <h3 class="small-text" style="color: var(--accent-purple);">Peano Axioms: Generating Natural Numbers</h3>
            <div class="equation-box small-text">
                $0, \; S(0), \; S(S(0)), \; S(S(S(0))), \; \ldots$
            </div>
            <p class="tiny-text">Start with 0, apply successor function S repeatedly &rarr; all natural numbers</p>
        </div>
        <div class="fragment" style="margin-top: 20px;">
            <p class="small-text">This is just a <strong>for loop</strong>:</p>
            <pre><code class="python">i = 0
for _ in range(n):
    i = i + 1  # successor</code></pre>
        </div>
    </section>

    <section>
        <h2>Example: Fibonacci Sequence</h2>
        <div class="equation-box">
            $F_n = F_{n-1} + F_{n-2}$
        </div>
        <p class="small-text">Simple rule &rarr; Complex, interesting sequence</p>
        <div class="two-column" style="margin-top: 20px;">
            <div>
                <pre><code class="python">def fib(n):
    a, b = 0, 1
    for _ in range(n):
        a, b = b, a + b
    return a</code></pre>
            </div>
            <div class="fragment">
                <p class="small-text">Properties emerge:</p>
                <ul class="tiny-text">
                    <li>Ratios converge to golden ratio $\phi$</li>
                    <li>Which are prime? Even?</li>
                    <li>Open questions in number theory!</li>
                </ul>
            </div>
        </div>
        <div class="fragment highlight-box small-text" style="margin-top: 15px;">
            <strong>Pattern:</strong> Simple recursive rule &rarr; Generate sequence &rarr; Ask questions about properties
        </div>
    </section>

    <section>
        <h2>Historical Example: Titius-Bode Law</h2>
        <p class="small-text">Planetary distances follow a pattern:</p>
        <div class="equation-box small-text">
            $a_n = 0.4 + 0.3 \times 2^n$ (in AU)
        </div>
        <div class="fragment" style="margin-top: 15px;">
            <p class="small-text">The process:</p>
            <ol class="small-text">
                <li>Observe data (planetary distances)</li>
                <li>Find the rule (the formula)</li>
                <li><strong>Use the rule to predict</strong> &rarr; missing planet?</li>
            </ol>
        </div>
        <div class="fragment success-box small-text" style="margin-top: 15px;">
            This predicted the asteroid belt and helped discover Uranus!
        </div>
    </section>
</section>

<!-- ============================================ -->
<!-- DIFFERENTIAL EQUATIONS TO DISCRETE -->
<!-- ============================================ -->
<section>
    <section>
        <h2>From Differential Equations to Discrete</h2>
        <p>Recall Galileo's projectile: $\displaystyle\frac{d^2x}{dt^2} = -g$</p>
        <p class="fragment">We integrated analytically: $x(t) = -\frac{1}{2}gt^2 + v_0 t + x_0$</p>
        <div class="fragment warning-box" style="margin-top: 20px;">
            <strong>Problem:</strong> Most equations can't be integrated analytically!
        </div>
        <p class="fragment" style="margin-top: 15px;"><strong>Solution:</strong> Solve on a computer by going back to discrete</p>
    </section>

    <section>
        <h2>Discretization</h2>
        <p>Turn derivatives back into differences:</p>
        <div class="equation-box">
            $\frac{dx}{dt} \approx \frac{x_{n+1} - x_n}{\Delta t}$
        </div>
        <div class="fragment" style="margin-top: 20px;">
            <p>For $\frac{d^2x}{dt^2} = -g$, introduce velocity $v = \frac{dx}{dt}$:</p>
            <div class="two-column small-text">
                <div class="equation-box">
                    $v_{n+1} = v_n - g \cdot \Delta t$
                </div>
                <div class="equation-box">
                    $x_{n+1} = x_n + v_n \cdot \Delta t$
                </div>
            </div>
        </div>
        <div class="fragment highlight-box small-text" style="margin-top: 15px;">
            Like Fibonacci: given previous values, compute the next one recursively!
        </div>
    </section>

    <section>
        <h2>Interactive: Step-by-Step Integration</h2>
        <div class="two-column">
            <div style="flex: 1.2;">
                <svg id="euler-plot" width="480" height="300" style="background: rgba(0,0,0,0.2); border-radius: 8px;"></svg>
                <div style="display: flex; gap: 15px; margin-top: 10px; flex-wrap: wrap;">
                    <div class="slider-container">
                        <label>$\Delta t$:</label>
                        <input type="range" id="euler-dt" min="0.05" max="0.5" step="0.05" value="0.2">
                        <span id="euler-dt-val">0.20</span>
                    </div>
                    <button onclick="eulerStep()" id="euler-step-btn" style="padding: 5px 15px; cursor: pointer; border-radius: 4px; border: none; background: #61afef; color: white;">Step</button>
                    <button onclick="eulerReset()" style="padding: 5px 15px; cursor: pointer; border-radius: 4px; border: none; background: #e06c75; color: white;">Reset</button>
                </div>
            </div>
            <div style="flex: 1;">
                <div id="euler-computation" class="highlight-box small-text" style="min-height: 200px; font-family: monospace;">
                    <div style="margin-bottom: 10px;"><strong>Initial conditions:</strong></div>
                    <div>$x_0 = 0$ m</div>
                    <div>$v_0 = 15$ m/s (upward)</div>
                    <div>$g = 9.8$ m/s²</div>
                    <div style="margin-top: 15px; color: #888;">Click "Step" to begin...</div>
                </div>
            </div>
        </div>
        <p class="tiny-text center-text" style="margin-top: 10px; color: #888;">
            <span style="color: #61afef;">Blue dots</span> = Numerical (Euler) |
            <span style="color: #98c379;">Green dashed</span> = Analytical solution
        </p>
    </section>

    <section>
        <h2>The Role of $\Delta t$</h2>
        <p>$\Delta t$ controls the <strong>accuracy</strong> of the approximation</p>
        <ul class="small-text">
            <li class="fragment">Smaller $\Delta t$ &rarr; more accurate, but slower</li>
            <li class="fragment">Larger $\Delta t$ &rarr; faster, but less accurate</li>
            <li class="fragment">Too large &rarr; solution can become <strong>unstable</strong>!</li>
        </ul>
        <div class="fragment principle-box small-text" style="margin-top: 20px;">
            <strong>Key trade-off:</strong> Speed vs Accuracy
        </div>
    </section>
</section>

<!-- ============================================ -->
<!-- PREDATOR-PREY -->
<!-- ============================================ -->
<section>
    <section>
        <h2>Case Study: The Hudson Bay Fur Records</h2>
        <div class="two-column">
            <div>
                <p class="small-text"><strong>Historical context:</strong></p>
                <ul class="tiny-text">
                    <li><strong>1670-1920s:</strong> Hudson's Bay Company traded furs in Canada</li>
                    <li>Kept meticulous records of pelts purchased each year</li>
                    <li><strong>1924:</strong> Ecologist Charles Elton analyzed 90 years of data</li>
                    <li>Discovered striking ~10-year cycles in lynx and hare populations</li>
                </ul>
                <div class="fragment highlight-box tiny-text" style="margin-top: 10px;">
                    <strong>The puzzle:</strong> Why do populations oscillate so regularly?<br>
                    Can we build a mathematical model to explain this?
                </div>
            </div>
            <div>
                <svg id="hudson-data-viz" width="420" height="280" style="background: rgba(0,0,0,0.2); border-radius: 8px;"></svg>
                <p class="tiny-text" style="text-align: center; color: #888;">
                    Hudson Bay Company records (1900-1920)<br>
                    <span style="color: #61afef;">■ Hare</span> | <span style="color: #e06c75;">■ Lynx</span> (thousands)
                </p>
            </div>
        </div>
    </section>

    <section>
        <h2>The Lotka-Volterra Model</h2>
        <p class="small-text">Lotka (1925) and Volterra (1926) independently proposed:</p>
        <div class="two-column" style="margin-top: 15px;">
            <div>
                <p class="small-text"><strong>The logic:</strong></p>
                <ul class="tiny-text">
                    <li>More prey &rarr; predators thrive</li>
                    <li>More predators &rarr; eat more prey</li>
                    <li>Fewer prey &rarr; predators starve</li>
                    <li>Fewer predators &rarr; prey recover</li>
                    <li>&rarr; <strong>Oscillation!</strong></li>
                </ul>
            </div>
            <div>
                <div class="equation-box small-text">
                    $\displaystyle\frac{dx}{dt} = \color{#98c379}{\alpha}\, x - \color{#e5c07b}{\beta}\, xy$<br><br>
                    $\displaystyle\frac{dy}{dt} = \color{#c678dd}{\delta}\, xy - \color{#56b6c2}{\gamma}\, y$
                </div>
                <p class="tiny-text" style="margin-top: 10px;">
                    $x$ = prey (hares), $y$ = predators (lynx)<br>
                    <span style="color: #98c379;">α</span> = prey growth |
                    <span style="color: #e5c07b;">β</span> = predation rate<br>
                    <span style="color: #c678dd;">δ</span> = predator efficiency |
                    <span style="color: #56b6c2;">γ</span> = predator death
                </p>
            </div>
        </div>
    </section>

    <section>
        <h2>Discretizing the Equations</h2>
        <p class="small-text">Apply Euler's method to each equation:</p>
        <div class="two-column" style="margin-top: 15px;">
            <div>
                <div class="highlight-box small-text">
                    <strong>Continuous:</strong><br>
                    $\displaystyle\frac{dx}{dt} = \alpha x - \beta xy$<br><br>
                    $\displaystyle\frac{dy}{dt} = \delta xy - \gamma y$
                </div>
            </div>
            <div>
                <div class="success-box small-text">
                    <strong>Discrete (Euler):</strong><br>
                    $x_{n+1} = x_n + \Delta t \cdot (\alpha x_n - \beta x_n y_n)$<br><br>
                    $y_{n+1} = y_n + \Delta t \cdot (\delta x_n y_n - \gamma y_n)$
                </div>
            </div>
        </div>
        <div class="fragment principle-box small-text" style="margin-top: 20px;">
            <strong>The recipe:</strong> Given $(x_n, y_n)$ at time $t_n$, compute $(x_{n+1}, y_{n+1})$ at time $t_{n+1} = t_n + \Delta t$
        </div>
    </section>

    <section>
        <h2>Fitting the Model to Data</h2>
        <div class="two-column">
            <div style="flex: 1.5;">
                <svg id="predprey-fit-viz" width="550" height="320" style="background: rgba(0,0,0,0.2); border-radius: 8px;"></svg>
            </div>
            <div style="flex: 1;">
                <div class="equation-box tiny-text" style="padding: 10px;">
                    $\displaystyle\frac{dx}{dt} = \color{#98c379}{\alpha}\, x - \color{#e5c07b}{\beta}\, xy$<br><br>
                    $\displaystyle\frac{dy}{dt} = \color{#c678dd}{\delta}\, xy - \color{#56b6c2}{\gamma}\, y$
                </div>
                <div style="margin-top: 10px;">
                    <div class="slider-container">
                        <label style="color: #98c379;">α:</label>
                        <input type="range" id="pp-alpha" min="0.2" max="1.0" step="0.02" value="0.55">
                        <span id="pp-alpha-val" style="color: #98c379;">0.55</span>
                    </div>
                    <div class="slider-container">
                        <label style="color: #e5c07b;">β:</label>
                        <input type="range" id="pp-beta" min="0.01" max="0.1" step="0.005" value="0.028">
                        <span id="pp-beta-val" style="color: #e5c07b;">0.028</span>
                    </div>
                    <div class="slider-container">
                        <label style="color: #c678dd;">δ:</label>
                        <input type="range" id="pp-delta" min="0.005" max="0.05" step="0.002" value="0.018">
                        <span id="pp-delta-val" style="color: #c678dd;">0.018</span>
                    </div>
                    <div class="slider-container">
                        <label style="color: #56b6c2;">γ:</label>
                        <input type="range" id="pp-gamma" min="0.2" max="1.2" step="0.02" value="0.84">
                        <span id="pp-gamma-val" style="color: #56b6c2;">0.84</span>
                    </div>
                </div>
                <button onclick="resetPredPreyFit()" style="margin-top: 10px; padding: 5px 15px; cursor: pointer; border-radius: 4px; border: none; background: #61afef; color: white; width: 100%;">Reset Parameters</button>
            </div>
        </div>
        <p class="tiny-text center-text" style="margin-top: 5px; color: #888;">
            Dots = Real data | Lines = Model simulation |
            <span style="color: #61afef;">Hare</span> | <span style="color: #e06c75;">Lynx</span>
        </p>
    </section>
</section>

<!-- ============================================ -->
<!-- PENDULUM -->
<!-- ============================================ -->
<section>
    <section>
        <h2>Case Study: The Pendulum</h2>
        <p>The equation of motion:</p>
        <div class="equation-box">
            $\displaystyle\frac{d^2\theta}{dt^2} = -\frac{g}{L}\sin\theta$
        </div>
        <div class="fragment" style="margin-top: 20px;">
            <p class="small-text">For small angles: $\sin\theta \approx \theta$ &rarr; simple harmonic motion</p>
            <p class="small-text">For large angles: <strong>nonlinear!</strong> Must solve numerically.</p>
        </div>
    </section>

    <section>
        <h2>Discretizing the Pendulum</h2>
        <p class="small-text">Introduce angular velocity $\omega = \frac{d\theta}{dt}$, then apply Euler:</p>
        <div class="two-column" style="margin-top: 15px;">
            <div>
                <div class="highlight-box small-text">
                    <strong>Continuous:</strong><br>
                    $\displaystyle\frac{d\theta}{dt} = \omega$<br><br>
                    $\displaystyle\frac{d\omega}{dt} = -\frac{g}{L}\sin\theta$
                </div>
            </div>
            <div>
                <div class="success-box small-text">
                    <strong>Discrete (Euler):</strong><br>
                    $\theta_{n+1} = \theta_n + \Delta t \cdot \omega_n$<br><br>
                    $\omega_{n+1} = \omega_n - \Delta t \cdot \frac{g}{L}\sin\theta_n$
                </div>
            </div>
        </div>
        <div class="fragment principle-box small-text" style="margin-top: 20px;">
            <strong>Same pattern:</strong> Given $(\theta_n, \omega_n)$ at time $t_n$, compute $(\theta_{n+1}, \omega_{n+1})$ at $t_{n+1} = t_n + \Delta t$
        </div>
    </section>

    <section>
        <h2>Pendulum Phase Space</h2>
        <div class="two-column">
            <div>
                <svg id="pendulum-viz" width="250" height="250" style="background: rgba(0,0,0,0.2); border-radius: 8px;"></svg>
                <div class="slider-container" style="margin-top: 10px;">
                    <label style="min-width: 30px;">θ₀:</label>
                    <input type="range" id="pend-theta0" min="0.1" max="3.0" step="0.1" value="0.5">
                    <span id="pend-theta0-val">0.5</span>
                </div>
            </div>
            <div>
                <svg id="phase-viz" width="400" height="300" style="background: rgba(0,0,0,0.2); border-radius: 8px;"></svg>
            </div>
        </div>
        <p class="tiny-text center-text" style="margin-top: 10px;">
            Left: Pendulum animation | Right: Phase space (θ, ω)
        </p>
    </section>

    <section>
        <h2>Phase Space: The Full Picture</h2>
        <div style="display: flex; justify-content: center;">
            <svg id="phase-flow-viz" width="700" height="350" style="background: rgba(0,0,0,0.2); border-radius: 8px;"></svg>
        </div>
        <p class="small-text center-text" style="margin-top: 10px;">
            Multiple trajectories in phase space for different initial conditions
        </p>
        <p class="tiny-text center-text" style="color: #888;">
            Small $\theta_0$: circles | Large $\theta_0$: distorted "eye" shapes
        </p>
    </section>
</section>

<!-- ============================================ -->
<!-- ERROR ANALYSIS -->
<!-- ============================================ -->
<section>
    <section>
        <h2>Error Analysis: How Accurate?</h2>
        <p>Unlike Fibonacci (exact), numerical solutions have <strong>error</strong></p>
        <p class="fragment">Use <strong>Taylor expansion</strong> to estimate error:</p>
        <div class="fragment equation-box tiny-text" style="padding: 15px;">
            $x(t + \Delta t) = x(t) + \Delta t \cdot \dot{x}(t) + \frac{(\Delta t)^2}{2}\ddot{x}(t) + O((\Delta t)^3)$
        </div>
        <div class="fragment" style="margin-top: 15px;">
            <p class="small-text">Rearranging for the derivative:</p>
            <div class="equation-box tiny-text" style="padding: 15px;">
                $\displaystyle\frac{x(t + \Delta t) - x(t)}{\Delta t} = \dot{x}(t) + \underbrace{\frac{\Delta t}{2}\ddot{x}(t) + O((\Delta t)^2)}_{\text{Error} = O(\Delta t)}$
            </div>
        </div>
        <p class="fragment tiny-text" style="margin-top: 10px; color: #888;">
            The $(\Delta t)^2$ term becomes $O(\Delta t)$ after dividing by $\Delta t$
        </p>
    </section>

    <section>
        <h2>Finite Difference Schemes</h2>
        <div class="three-column small-text">
            <div class="highlight-box" style="text-align: center;">
                <strong>Forward</strong><br>
                $\displaystyle\frac{x_{n+1} - x_n}{\Delta t}$<br><br>
                Error: $O(\Delta t)$
            </div>
            <div class="highlight-box" style="text-align: center;">
                <strong>Backward</strong><br>
                $\displaystyle\frac{x_n - x_{n-1}}{\Delta t}$<br><br>
                Error: $O(\Delta t)$
            </div>
            <div class="success-box" style="text-align: center;">
                <strong>Central</strong><br>
                $\displaystyle\frac{x_{n+1} - x_{n-1}}{2\Delta t}$<br><br>
                Error: $O((\Delta t)^2)$
            </div>
        </div>
        <p class="fragment small-text" style="margin-top: 20px; text-align: center;">
            Central difference is more accurate for the same $\Delta t$!
        </p>
    </section>

    <section>
        <h2>Second Derivative</h2>
        <div class="equation-box">
            $\frac{d^2 x}{dt^2} \approx \frac{x_{n+1} - 2x_n + x_{n-1}}{(\Delta t)^2}$
        </div>
        <p class="small-text" style="margin-top: 15px;">Error: $O((\Delta t)^2)$</p>
        <div class="fragment highlight-box small-text" style="margin-top: 20px;">
            <strong>The pattern:</strong> Higher-order schemes = more neighbors used = better accuracy = more computation
        </div>
    </section>
</section>

<!-- ============================================ -->
<!-- PDEs: DIFFUSION -->
<!-- ============================================ -->
<section>
    <section>
        <h2>PDEs: Functions of Space AND Time</h2>
        <p>Now $u(x, t)$ depends on both space and time</p>
        <div class="equation-box">
            <strong>Diffusion Equation:</strong> $\displaystyle\frac{\partial u}{\partial t} = D\frac{\partial^2 u}{\partial x^2}$
        </div>
        <div class="fragment" style="margin-top: 20px;">
            <p class="small-text"><strong>Examples where diffusion appears:</strong></p>
            <ul class="tiny-text">
                <li><strong>Heat conduction:</strong> Temperature spreads through a material</li>
                <li><strong>Chemical diffusion:</strong> Ink spreading in water, pollutants in air</li>
                <li><strong>Electrical signals:</strong> Current spreading in neural axons</li>
                <li><strong>Population dynamics:</strong> Species spreading into new territory</li>
                <li><strong>Information:</strong> Rumors spreading through a network</li>
            </ul>
        </div>
    </section>

    <section>
        <h2>Discretizing Space and Time</h2>
        <p class="small-text">Define a grid with spacing $\Delta x$ in space and $\Delta t$ in time:</p>
        <div class="equation-box small-text" style="margin-top: 15px;">
            $u_i^n \equiv u(x_i, t_n)$ where $x_i = i \cdot \Delta x$ and $t_n = n \cdot \Delta t$
        </div>
        <div class="fragment" style="margin-top: 20px;">
            <p class="small-text">Apply finite differences to both derivatives:</p>
            <div class="two-column tiny-text" style="margin-top: 10px;">
                <div class="highlight-box" style="text-align: center;">
                    <strong>Time derivative:</strong><br>
                    $\displaystyle\frac{\partial u}{\partial t} \approx \frac{u_i^{n+1} - u_i^n}{\Delta t}$
                </div>
                <div class="highlight-box" style="text-align: center;">
                    <strong>Space derivative:</strong><br>
                    $\displaystyle\frac{\partial^2 u}{\partial x^2} \approx \frac{u_{i+1}^n - 2u_i^n + u_{i-1}^n}{(\Delta x)^2}$
                </div>
            </div>
        </div>
        <div class="fragment success-box small-text" style="margin-top: 15px;">
            <strong>Discrete update rule:</strong> $\quad u_i^{n+1} = u_i^n + D\frac{\Delta t}{(\Delta x)^2}(u_{i+1}^n - 2u_i^n + u_{i-1}^n)$
        </div>
    </section>

    <section>
        <h2>PDE Discretization: Step by Step</h2>
        <div class="two-column">
            <div style="flex: 1.3;">
                <svg id="pde-grid-viz" width="550" height="320" style="background: rgba(0,0,0,0.2); border-radius: 8px;"></svg>
            </div>
            <div style="flex: 0.7;">
                <div id="pde-formula-box" class="highlight-box tiny-text" style="min-height: 120px; font-family: monospace;">
                    <div style="margin-bottom: 8px;"><strong>Current stencil:</strong></div>
                    <div style="color: #888;">Click "Step" to begin...</div>
                </div>
                <div style="margin-top: 10px;">
                    <svg id="pde-colorbar" width="200" height="30"></svg>
                    <p class="tiny-text" style="margin: 0; color: #888;">u value (0 to 1)</p>
                </div>
            </div>
        </div>
        <div style="text-align: center; margin-top: 10px;">
            <button onclick="pdeStepBack()" style="padding: 5px 15px; margin: 0 5px; cursor: pointer; border-radius: 4px; border: none; background: #666; color: white;">← Back</button>
            <button onclick="pdeStepStencil()" style="padding: 5px 15px; margin: 0 5px; cursor: pointer; border-radius: 4px; border: none; background: #61afef; color: white;">Step Stencil →</button>
            <button onclick="pdeStepRow()" style="padding: 5px 15px; margin: 0 5px; cursor: pointer; border-radius: 4px; border: none; background: #c678dd; color: white;">Next Row ↑</button>
            <button onclick="pdeReset()" style="padding: 5px 15px; margin: 0 5px; cursor: pointer; border-radius: 4px; border: none; background: #e06c75; color: white;">Reset</button>
        </div>
        <p class="tiny-text center-text" style="margin-top: 5px; color: #888;">
            "Step Stencil" moves one cell in space | "Next Row" completes a time step
        </p>
    </section>

    <section>
        <h2>The Stencil</h2>
        <p class="small-text">Each new value depends on neighboring values:</p>
        <div class="three-column" style="margin-top: 20px; text-align: center;">
            <div>
                <p class="tiny-text"><strong>FTCS</strong></p>
                <p class="tiny-text" style="color: #888;">(Forward Time, Central Space)</p>
                <div class="stencil-grid">
                    <div class="stencil-cell stencil-inactive"></div>
                    <div class="stencil-cell stencil-target">$u_i^{n+1}$</div>
                    <div class="stencil-cell stencil-inactive"></div>
                    <div class="stencil-cell stencil-active">$u_{i-1}^n$</div>
                    <div class="stencil-cell stencil-active">$u_i^n$</div>
                    <div class="stencil-cell stencil-active">$u_{i+1}^n$</div>
                </div>
                <p class="tiny-text" style="margin-top: 8px;">$u_i^{n+1} = u_i^n + r(u_{i+1}^n - 2u_i^n + u_{i-1}^n)$</p>
            </div>
            <div class="fragment">
                <p class="tiny-text"><strong>BTCS</strong></p>
                <p class="tiny-text" style="color: #888;">(Backward Time, Central Space)</p>
                <div class="stencil-grid">
                    <div class="stencil-cell stencil-active">$u_{i-1}^{n+1}$</div>
                    <div class="stencil-cell stencil-active">$u_i^{n+1}$</div>
                    <div class="stencil-cell stencil-active">$u_{i+1}^{n+1}$</div>
                    <div class="stencil-cell stencil-inactive"></div>
                    <div class="stencil-cell stencil-target">$u_i^n$</div>
                    <div class="stencil-cell stencil-inactive"></div>
                </div>
                <p class="tiny-text" style="margin-top: 8px;">$u_i^{n+1} - r(u_{i+1}^{n+1} - 2u_i^{n+1} + u_{i-1}^{n+1}) = u_i^n$</p>
            </div>
            <div class="fragment">
                <p class="tiny-text"><strong>Crank-Nicolson</strong></p>
                <p class="tiny-text" style="color: #888;">(Average of FTCS + BTCS)</p>
                <div class="stencil-grid">
                    <div class="stencil-cell stencil-active">●</div>
                    <div class="stencil-cell stencil-active">●</div>
                    <div class="stencil-cell stencil-active">●</div>
                    <div class="stencil-cell stencil-active">●</div>
                    <div class="stencil-cell stencil-active">●</div>
                    <div class="stencil-cell stencil-active">●</div>
                </div>
                <p class="tiny-text" style="margin-top: 8px;">$O((\Delta t)^2, (\Delta x)^2)$ accuracy</p>
            </div>
        </div>
    </section>

    <section>
        <h2>Stability: The CFL Condition</h2>
        <div class="two-column">
            <div style="flex: 1;">
                <svg id="cfl-demo-viz" width="400" height="280" style="background: rgba(0,0,0,0.2); border-radius: 8px;"></svg>
                <div class="slider-container" style="margin-top: 10px;">
                    <label>r =</label>
                    <input type="range" id="cfl-r" min="0.1" max="0.8" step="0.05" value="0.4">
                    <span id="cfl-r-val">0.40</span>
                </div>
                <div style="text-align: center; margin-top: 5px;">
                    <button onclick="runCFLDemo()" style="padding: 5px 20px; cursor: pointer; border-radius: 4px; border: none; background: #61afef; color: white;">Run Simulation</button>
                </div>
            </div>
            <div style="flex: 1;">
                <div class="equation-box small-text">
                    <strong>CFL Condition:</strong><br><br>
                    $r = \frac{D \cdot \Delta t}{(\Delta x)^2} \leq \frac{1}{2}$
                </div>
                <div id="cfl-status" class="success-box small-text" style="margin-top: 15px;">
                    <strong>r = 0.40:</strong> Stable ✓<br>
                    Solution remains bounded
                </div>
                <p class="tiny-text" style="margin-top: 10px; color: #888;">
                    Try r > 0.5 to see instability!
                </p>
            </div>
        </div>
        <div class="fragment warning-box small-text" style="margin-top: 15px;">
            <strong>Implicit schemes</strong> (BTCS, Crank-Nicolson) are unconditionally stable but require solving linear systems.
        </div>
    </section>
</section>

<!-- ============================================ -->
<!-- RUNGE-KUTTA -->
<!-- ============================================ -->
<section>
    <section>
        <h2>Better Integrators: Runge-Kutta</h2>
        <p class="small-text">The workhorse of scientific computing</p>
        <div class="equation-box small-text">
            <strong>RK4 (4th-order Runge-Kutta):</strong><br><br>
            $k_1 = f(t_n, y_n)$<br>
            $k_2 = f(t_n + \frac{\Delta t}{2}, y_n + \frac{\Delta t}{2}k_1)$<br>
            $k_3 = f(t_n + \frac{\Delta t}{2}, y_n + \frac{\Delta t}{2}k_2)$<br>
            $k_4 = f(t_n + \Delta t, y_n + \Delta t \cdot k_3)$<br><br>
            $y_{n+1} = y_n + \frac{\Delta t}{6}(k_1 + 2k_2 + 2k_3 + k_4)$
        </div>
    </section>

    <section>
        <h2>Why RK4?</h2>
        <ul>
            <li class="fragment">Error: $O((\Delta t)^4)$ — much better than Euler!</li>
            <li class="fragment">Evaluates $f$ at multiple points per step</li>
            <li class="fragment">Good balance of accuracy and efficiency</li>
            <li class="fragment">Used in most ODE solvers (MATLAB's <code>ode45</code>, SciPy's <code>solve_ivp</code>)</li>
        </ul>
        <div class="fragment highlight-box small-text" style="margin-top: 20px;">
            <strong>Adaptive methods:</strong> Automatically adjust $\Delta t$ based on estimated error
        </div>
    </section>
</section>

<!-- ============================================ -->
<!-- FINITE VOLUME -->
<!-- ============================================ -->
<section>
    <h2>Preserving Physics: Finite Volume Methods</h2>
    <p class="small-text">When equations have <strong>conservative form</strong>:</p>
    <div class="equation-box">
        $\frac{\partial \rho}{\partial t} + \frac{\partial F}{\partial x} = 0$
    </div>
    <p class="fragment small-text" style="margin-top: 15px;">Finite volume methods ensure <strong>conservation is preserved</strong> in the discretization.</p>
    <div class="fragment principle-box small-text" style="margin-top: 15px;">
        <strong>Key idea:</strong> What flows out of one cell flows into the next.<br>
        No mass/energy is created or destroyed numerically.
    </div>
    <p class="fragment small-text" style="margin-top: 15px;">
        Theme in Scientific ML: <strong>Encode physical knowledge into numerical schemes</strong>
    </p>
</section>

<!-- ============================================ -->
<!-- 2D FLUID SIMULATOR -->
<!-- ============================================ -->
<section>
    <section>
        <h2>Interactive: 2D Fluid Dynamics</h2>
        <div style="display: flex; justify-content: center;">
            <canvas id="fluid-canvas" width="600" height="400" style="border-radius: 8px; cursor: crosshair;"></canvas>
        </div>
        <p class="tiny-text center-text" style="margin-top: 10px; color: #888;">
            Move mouse to add forcing | This is a real Navier-Stokes solver running in your browser!
        </p>
    </section>

    <section>
        <h2>The Solver Code (Core Loop)</h2>
        <pre><code class="javascript">// Simplified 2D Navier-Stokes solver
function fluidStep() {
    // 1. Add forces (from mouse input)
    addForce(u, v, forceX, forceY);

    // 2. Diffuse velocity (viscosity)
    diffuse(u, u0, viscosity, dt);
    diffuse(v, v0, viscosity, dt);

    // 3. Project to make divergence-free
    project(u, v, p, div);

    // 4. Advect velocity field
    advect(u, u0, u0, v0, dt);
    advect(v, v0, u0, v0, dt);

    // 5. Project again
    project(u, v, p, div);

    // 6. Advect density (for visualization)
    advect(density, density0, u, v, dt);
}</code></pre>
        <p class="tiny-text" style="margin-top: 10px;">Based on Jos Stam's "Stable Fluids" (1999)</p>
    </section>

    <section>
        <h2>Key Steps Explained</h2>
        <table class="comparison small-text">
            <tr>
                <th>Step</th>
                <th>What it does</th>
                <th>Physics</th>
            </tr>
            <tr>
                <td><strong>Diffuse</strong></td>
                <td>Spread velocity via Laplacian</td>
                <td>Viscosity ($\mu\nabla^2\mathbf{u}$)</td>
            </tr>
            <tr>
                <td><strong>Project</strong></td>
                <td>Make velocity divergence-free</td>
                <td>Incompressibility ($\nabla \cdot \mathbf{u} = 0$)</td>
            </tr>
            <tr>
                <td><strong>Advect</strong></td>
                <td>Move quantities along flow</td>
                <td>Material transport ($\mathbf{u} \cdot \nabla$)</td>
            </tr>
        </table>
        <div class="fragment highlight-box small-text" style="margin-top: 15px;">
            Each step corresponds to a term in the Navier-Stokes equations!
        </div>
    </section>
</section>

<!-- ============================================ -->
<!-- LORENZ SYSTEM -->
<!-- ============================================ -->
<section>
    <section>
        <h2>Chaos: The Lorenz System</h2>
        <p class="small-text">Edward Lorenz (1963): Simplified weather model</p>
        <div class="equation-box small-text">
            $\dot{x} = \sigma(y - x)$<br>
            $\dot{y} = x(\rho - z) - y$<br>
            $\dot{z} = xy - \beta z$
        </div>
        <p class="fragment small-text" style="margin-top: 15px;">
            Typical parameters: $\sigma = 10$, $\rho = 28$, $\beta = 8/3$
        </p>
    </section>

    <section>
        <h2>The Lorenz Attractor</h2>
        <div style="display: flex; justify-content: center;">
            <svg id="lorenz-viz" width="500" height="400" style="background: rgba(0,0,0,0.2); border-radius: 8px;"></svg>
        </div>
        <div style="text-align: center; margin-top: 10px;">
            <button onclick="resetLorenz()" style="padding: 5px 15px; cursor: pointer; border-radius: 4px; border: none; background: #61afef; color: white;">Reset</button>
            <button onclick="perturbLorenz()" style="padding: 5px 15px; margin-left: 10px; cursor: pointer; border-radius: 4px; border: none; background: #e5c07b; color: black;">Add Perturbed Trajectory</button>
        </div>
    </section>

    <section>
        <h2>Sensitivity to Initial Conditions</h2>
        <div style="display: flex; justify-content: center;">
            <svg id="lorenz-sensitivity-viz" width="800" height="350" style="background: rgba(0,0,0,0.2); border-radius: 8px;"></svg>
        </div>
        <div class="slider-container" style="justify-content: center; margin-top: 10px;">
            <label>Perturbation:</label>
            <input type="range" id="lorenz-perturb" min="-6" max="-1" step="0.5" value="-4">
            <span id="lorenz-perturb-val">$10^{-4}$</span>
        </div>
        <p class="tiny-text center-text" style="color: #888;">
            <span style="color: #61afef;">Blue</span> vs <span style="color: #e06c75;">Red</span>: Trajectories starting $\epsilon$ apart
        </p>
    </section>

    <section>
        <h2>The Butterfly Effect</h2>
        <blockquote style="font-size: 0.85em;">
            "Does the flap of a butterfly's wings in Brazil set off a tornado in Texas?"
            <footer>— Edward Lorenz, 1972</footer>
        </blockquote>
        <div class="fragment warning-box" style="margin-top: 20px;">
            <strong>The challenge:</strong> If deterministic systems can be this sensitive, what are we actually predicting?
        </div>
        <p class="fragment small-text" style="margin-top: 15px;">
            Weather prediction has a fundamental limit (~2 weeks), not due to model errors, but due to <strong>chaos</strong>.
        </p>
    </section>
</section>

<!-- ============================================ -->
<!-- SUMMARY -->
<!-- ============================================ -->
<section>
    <h2>Summary</h2>
    <ol class="small-text">
        <li class="fragment"><strong>Computing = recursive rule application</strong> (from Peano to PDEs)</li>
        <li class="fragment"><strong>Discretization:</strong> Turn differential equations into algebraic ones</li>
        <li class="fragment"><strong>Error analysis:</strong> Taylor expansion tells us accuracy ($O(\Delta t)$, $O(\Delta t^2)$, ...)</li>
        <li class="fragment"><strong>Stability:</strong> Not all $\Delta t$ work; implicit vs explicit schemes</li>
        <li class="fragment"><strong>Runge-Kutta:</strong> The workhorse of ODE solving</li>
        <li class="fragment"><strong>Finite volume:</strong> Preserve physics (conservation) in numerics</li>
        <li class="fragment"><strong>Chaos:</strong> Sensitivity to initial conditions limits predictability</li>
    </ol>
</section>

<!-- ============================================ -->
<!-- LOOKING AHEAD -->
<!-- ============================================ -->
<section>
    <h2>Looking Ahead</h2>
    <p>If systems are chaotic and sensitive...</p>
    <p class="fragment"><strong>How do we account for uncertainty?</strong></p>
    <div class="fragment highlight-box" style="margin-top: 20px;">
        <strong>Next lecture:</strong> Probabilistic Modeling and Uncertainty Quantification
        <ul class="small-text" style="margin-top: 10px;">
            <li>Probability distributions over predictions</li>
            <li>Bayesian inference</li>
            <li>Monte Carlo methods</li>
            <li>Connecting uncertainty in ML and scientific computing</li>
        </ul>
    </div>
</section>

<section class="center-text">
    <h2>Questions?</h2>
    <p style="margin-top: 40px; color: #888;">See you next time!</p>
</section>

</div>
</div>

<script src="https://cdn.jsdelivr.net/npm/reveal.js@4.5.0/dist/reveal.js"></script>
<script src="https://cdn.jsdelivr.net/npm/reveal.js@4.5.0/plugin/math/math.js"></script>
<script src="https://cdn.jsdelivr.net/npm/reveal.js@4.5.0/plugin/highlight/highlight.js"></script>
<script>
    Reveal.initialize({
        hash: true,
        slideNumber: 'c/t',
        transition: 'slide',
        transitionSpeed: 'default',
        backgroundTransition: 'fade',
        plugins: [ RevealMath.KaTeX, RevealHighlight ],
        width: 1200,
        height: 700,
        margin: 0.1,
        minScale: 0.2,
        maxScale: 2.0
    });

    // ==========================================
    // PREDATOR-PREY: HUDSON BAY DATA & FITTING
    // ==========================================
    // Historical Hudson Bay Company data (1900-1920, approximate values in thousands)
    // Based on Elton & Nicholson (1942) and MacLulich (1937)
    const hudsonBayData = {
        years: [1900, 1901, 1902, 1903, 1904, 1905, 1906, 1907, 1908, 1909,
                1910, 1911, 1912, 1913, 1914, 1915, 1916, 1917, 1918, 1919, 1920],
        hare: [30, 47, 70, 78, 36, 20, 9, 7, 10, 28,
               55, 82, 73, 40, 18, 10, 8, 13, 28, 55, 80],
        lynx: [4, 7, 12, 25, 44, 36, 15, 5, 3, 4,
               6, 12, 22, 38, 50, 32, 12, 5, 4, 5, 8]
    };

    function drawHudsonData() {
        const svg = document.getElementById('hudson-data-viz');
        if (!svg) return;

        const width = 420, height = 280;
        const margin = { top: 20, right: 20, bottom: 40, left: 45 };
        const plotW = width - margin.left - margin.right;
        const plotH = height - margin.top - margin.bottom;

        svg.innerHTML = '';

        const g = document.createElementNS('http://www.w3.org/2000/svg', 'g');
        g.setAttribute('transform', `translate(${margin.left}, ${margin.top})`);
        svg.appendChild(g);

        // Axes
        const xAxis = document.createElementNS('http://www.w3.org/2000/svg', 'line');
        xAxis.setAttribute('x1', 0); xAxis.setAttribute('y1', plotH);
        xAxis.setAttribute('x2', plotW); xAxis.setAttribute('y2', plotH);
        xAxis.setAttribute('stroke', '#666'); xAxis.setAttribute('stroke-width', 1.5);
        g.appendChild(xAxis);

        const yAxis = document.createElementNS('http://www.w3.org/2000/svg', 'line');
        yAxis.setAttribute('x1', 0); yAxis.setAttribute('y1', 0);
        yAxis.setAttribute('x2', 0); yAxis.setAttribute('y2', plotH);
        yAxis.setAttribute('stroke', '#666'); yAxis.setAttribute('stroke-width', 1.5);
        g.appendChild(yAxis);

        // Labels
        const xLabel = document.createElementNS('http://www.w3.org/2000/svg', 'text');
        xLabel.setAttribute('x', plotW / 2); xLabel.setAttribute('y', plotH + 30);
        xLabel.setAttribute('fill', '#888'); xLabel.setAttribute('text-anchor', 'middle');
        xLabel.setAttribute('font-size', '11px');
        xLabel.textContent = 'Year';
        g.appendChild(xLabel);

        const yLabel = document.createElementNS('http://www.w3.org/2000/svg', 'text');
        yLabel.setAttribute('x', -plotH / 2); yLabel.setAttribute('y', -32);
        yLabel.setAttribute('fill', '#888'); yLabel.setAttribute('text-anchor', 'middle');
        yLabel.setAttribute('transform', 'rotate(-90)');
        yLabel.setAttribute('font-size', '11px');
        yLabel.textContent = 'Population (thousands)';
        g.appendChild(yLabel);

        const years = hudsonBayData.years;
        const tMin = years[0], tMax = years[years.length - 1];
        const maxPop = Math.max(...hudsonBayData.hare, ...hudsonBayData.lynx) * 1.1;

        // Draw hare data
        let harePath = '';
        hudsonBayData.hare.forEach((h, i) => {
            const x = ((years[i] - tMin) / (tMax - tMin)) * plotW;
            const y = plotH - (h / maxPop) * plotH;
            harePath += (i === 0 ? 'M' : 'L') + `${x},${y}`;
        });
        const hareCurve = document.createElementNS('http://www.w3.org/2000/svg', 'path');
        hareCurve.setAttribute('d', harePath);
        hareCurve.setAttribute('stroke', '#61afef');
        hareCurve.setAttribute('stroke-width', 2);
        hareCurve.setAttribute('fill', 'none');
        g.appendChild(hareCurve);

        // Draw lynx data
        let lynxPath = '';
        hudsonBayData.lynx.forEach((l, i) => {
            const x = ((years[i] - tMin) / (tMax - tMin)) * plotW;
            const y = plotH - (l / maxPop) * plotH;
            lynxPath += (i === 0 ? 'M' : 'L') + `${x},${y}`;
        });
        const lynxCurve = document.createElementNS('http://www.w3.org/2000/svg', 'path');
        lynxCurve.setAttribute('d', lynxPath);
        lynxCurve.setAttribute('stroke', '#e06c75');
        lynxCurve.setAttribute('stroke-width', 2);
        lynxCurve.setAttribute('fill', 'none');
        g.appendChild(lynxCurve);

        // Draw data points
        hudsonBayData.hare.forEach((h, i) => {
            const x = ((years[i] - tMin) / (tMax - tMin)) * plotW;
            const y = plotH - (h / maxPop) * plotH;
            const dot = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
            dot.setAttribute('cx', x); dot.setAttribute('cy', y);
            dot.setAttribute('r', 3); dot.setAttribute('fill', '#61afef');
            g.appendChild(dot);
        });

        hudsonBayData.lynx.forEach((l, i) => {
            const x = ((years[i] - tMin) / (tMax - tMin)) * plotW;
            const y = plotH - (l / maxPop) * plotH;
            const dot = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
            dot.setAttribute('cx', x); dot.setAttribute('cy', y);
            dot.setAttribute('r', 3); dot.setAttribute('fill', '#e06c75');
            g.appendChild(dot);
        });

        // Year tick marks
        [1900, 1905, 1910, 1915, 1920].forEach(yr => {
            const x = ((yr - tMin) / (tMax - tMin)) * plotW;
            const tick = document.createElementNS('http://www.w3.org/2000/svg', 'text');
            tick.setAttribute('x', x); tick.setAttribute('y', plotH + 15);
            tick.setAttribute('fill', '#888'); tick.setAttribute('text-anchor', 'middle');
            tick.setAttribute('font-size', '9px');
            tick.textContent = yr.toString();
            g.appendChild(tick);
        });
    }

    function initPredPreyFit() {
        drawPredPreyFit();
    }

    function drawPredPreyFit() {
        const svg = document.getElementById('predprey-fit-viz');
        if (!svg) return;

        const alpha = parseFloat(document.getElementById('pp-alpha')?.value || 0.55);
        const beta = parseFloat(document.getElementById('pp-beta')?.value || 0.028);
        const delta = parseFloat(document.getElementById('pp-delta')?.value || 0.018);
        const gamma = parseFloat(document.getElementById('pp-gamma')?.value || 0.84);

        // Update displays
        if (document.getElementById('pp-alpha-val')) document.getElementById('pp-alpha-val').textContent = alpha.toFixed(2);
        if (document.getElementById('pp-beta-val')) document.getElementById('pp-beta-val').textContent = beta.toFixed(3);
        if (document.getElementById('pp-delta-val')) document.getElementById('pp-delta-val').textContent = delta.toFixed(3);
        if (document.getElementById('pp-gamma-val')) document.getElementById('pp-gamma-val').textContent = gamma.toFixed(2);

        const width = 550, height = 320;
        const margin = { top: 20, right: 20, bottom: 40, left: 50 };
        const plotW = width - margin.left - margin.right;
        const plotH = height - margin.top - margin.bottom;

        svg.innerHTML = '';

        const g = document.createElementNS('http://www.w3.org/2000/svg', 'g');
        g.setAttribute('transform', `translate(${margin.left}, ${margin.top})`);
        svg.appendChild(g);

        // Axes
        const xAxis = document.createElementNS('http://www.w3.org/2000/svg', 'line');
        xAxis.setAttribute('x1', 0); xAxis.setAttribute('y1', plotH);
        xAxis.setAttribute('x2', plotW); xAxis.setAttribute('y2', plotH);
        xAxis.setAttribute('stroke', '#666'); xAxis.setAttribute('stroke-width', 1.5);
        g.appendChild(xAxis);

        const yAxis = document.createElementNS('http://www.w3.org/2000/svg', 'line');
        yAxis.setAttribute('x1', 0); yAxis.setAttribute('y1', 0);
        yAxis.setAttribute('x2', 0); yAxis.setAttribute('y2', plotH);
        yAxis.setAttribute('stroke', '#666'); yAxis.setAttribute('stroke-width', 1.5);
        g.appendChild(yAxis);

        // Labels
        const xLabel = document.createElementNS('http://www.w3.org/2000/svg', 'text');
        xLabel.setAttribute('x', plotW / 2); xLabel.setAttribute('y', plotH + 30);
        xLabel.setAttribute('fill', '#888'); xLabel.setAttribute('text-anchor', 'middle');
        xLabel.setAttribute('font-size', '11px');
        xLabel.textContent = 'Year';
        g.appendChild(xLabel);

        const yLabel = document.createElementNS('http://www.w3.org/2000/svg', 'text');
        yLabel.setAttribute('x', -plotH / 2); yLabel.setAttribute('y', -35);
        yLabel.setAttribute('fill', '#888'); yLabel.setAttribute('text-anchor', 'middle');
        yLabel.setAttribute('transform', 'rotate(-90)');
        yLabel.setAttribute('font-size', '11px');
        yLabel.textContent = 'Population (thousands)';
        g.appendChild(yLabel);

        const years = hudsonBayData.years;
        const tMin = years[0], tMax = years[years.length - 1];
        const maxPop = 100;

        // Simulate model using RK4
        const dt = 0.05;
        const simYears = 21;
        const stepsPerYear = Math.round(1 / dt);

        let x = hudsonBayData.hare[0];  // Initial hare population
        let y = hudsonBayData.lynx[0];  // Initial lynx population
        const simHare = [x];
        const simLynx = [y];
        const simTime = [0];

        for (let year = 0; year < simYears; year++) {
            for (let step = 0; step < stepsPerYear; step++) {
                // RK4 integration
                const f = (h, l) => [
                    alpha * h - beta * h * l,
                    delta * h * l - gamma * l
                ];
                const k1 = f(x, y);
                const k2 = f(x + dt/2 * k1[0], y + dt/2 * k1[1]);
                const k3 = f(x + dt/2 * k2[0], y + dt/2 * k2[1]);
                const k4 = f(x + dt * k3[0], y + dt * k3[1]);

                x += dt/6 * (k1[0] + 2*k2[0] + 2*k3[0] + k4[0]);
                y += dt/6 * (k1[1] + 2*k2[1] + 2*k3[1] + k4[1]);

                x = Math.max(0.1, x);
                y = Math.max(0.1, y);
            }
            simHare.push(x);
            simLynx.push(y);
            simTime.push(year + 1);
        }

        // Draw simulated hare line
        let simHarePath = '';
        simHare.forEach((h, i) => {
            const px = (simTime[i] / (tMax - tMin)) * plotW;
            const py = plotH - (Math.min(h, maxPop) / maxPop) * plotH;
            simHarePath += (i === 0 ? 'M' : 'L') + `${px},${py}`;
        });
        const simHareCurve = document.createElementNS('http://www.w3.org/2000/svg', 'path');
        simHareCurve.setAttribute('d', simHarePath);
        simHareCurve.setAttribute('stroke', '#61afef');
        simHareCurve.setAttribute('stroke-width', 2);
        simHareCurve.setAttribute('fill', 'none');
        g.appendChild(simHareCurve);

        // Draw simulated lynx line
        let simLynxPath = '';
        simLynx.forEach((l, i) => {
            const px = (simTime[i] / (tMax - tMin)) * plotW;
            const py = plotH - (Math.min(l, maxPop) / maxPop) * plotH;
            simLynxPath += (i === 0 ? 'M' : 'L') + `${px},${py}`;
        });
        const simLynxCurve = document.createElementNS('http://www.w3.org/2000/svg', 'path');
        simLynxCurve.setAttribute('d', simLynxPath);
        simLynxCurve.setAttribute('stroke', '#e06c75');
        simLynxCurve.setAttribute('stroke-width', 2);
        simLynxCurve.setAttribute('fill', 'none');
        g.appendChild(simLynxCurve);

        // Draw real data points (hare)
        hudsonBayData.hare.forEach((h, i) => {
            const px = ((years[i] - tMin) / (tMax - tMin)) * plotW;
            const py = plotH - (h / maxPop) * plotH;
            const dot = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
            dot.setAttribute('cx', px); dot.setAttribute('cy', py);
            dot.setAttribute('r', 5); dot.setAttribute('fill', '#61afef');
            dot.setAttribute('stroke', '#fff'); dot.setAttribute('stroke-width', 1);
            g.appendChild(dot);
        });

        // Draw real data points (lynx)
        hudsonBayData.lynx.forEach((l, i) => {
            const px = ((years[i] - tMin) / (tMax - tMin)) * plotW;
            const py = plotH - (l / maxPop) * plotH;
            const dot = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
            dot.setAttribute('cx', px); dot.setAttribute('cy', py);
            dot.setAttribute('r', 5); dot.setAttribute('fill', '#e06c75');
            dot.setAttribute('stroke', '#fff'); dot.setAttribute('stroke-width', 1);
            g.appendChild(dot);
        });

        // Year tick marks
        [1900, 1905, 1910, 1915, 1920].forEach(yr => {
            const x = ((yr - tMin) / (tMax - tMin)) * plotW;
            const tick = document.createElementNS('http://www.w3.org/2000/svg', 'text');
            tick.setAttribute('x', x); tick.setAttribute('y', plotH + 15);
            tick.setAttribute('fill', '#888'); tick.setAttribute('text-anchor', 'middle');
            tick.setAttribute('font-size', '10px');
            tick.textContent = yr.toString();
            g.appendChild(tick);
        });

        // Y-axis ticks
        [0, 25, 50, 75, 100].forEach(val => {
            const py = plotH - (val / maxPop) * plotH;
            const tick = document.createElementNS('http://www.w3.org/2000/svg', 'text');
            tick.setAttribute('x', -8); tick.setAttribute('y', py + 3);
            tick.setAttribute('fill', '#888'); tick.setAttribute('text-anchor', 'end');
            tick.setAttribute('font-size', '9px');
            tick.textContent = val.toString();
            g.appendChild(tick);
        });
    }

    function resetPredPreyFit() {
        document.getElementById('pp-alpha').value = 0.55;
        document.getElementById('pp-beta').value = 0.028;
        document.getElementById('pp-delta').value = 0.018;
        document.getElementById('pp-gamma').value = 0.84;
        drawPredPreyFit();
    }

    // ==========================================
    // PENDULUM SIMULATION
    // ==========================================
    let pendAnimId = null;
    let pendState = { theta: 0.5, omega: 0 };
    let pendTrail = [];

    function initPendulum() {
        const theta0 = parseFloat(document.getElementById('pend-theta0')?.value || 0.5);
        document.getElementById('pend-theta0-val').textContent = theta0.toFixed(1);
        pendState = { theta: theta0, omega: 0 };
        pendTrail = [];
        if (pendAnimId) cancelAnimationFrame(pendAnimId);
        animatePendulum();
    }

    function animatePendulum() {
        const g = 9.8, L = 1;
        const dt = 0.02;

        // RK4
        const f = (th, om) => [om, -(g/L) * Math.sin(th)];
        const k1 = f(pendState.theta, pendState.omega);
        const k2 = f(pendState.theta + dt/2 * k1[0], pendState.omega + dt/2 * k1[1]);
        const k3 = f(pendState.theta + dt/2 * k2[0], pendState.omega + dt/2 * k2[1]);
        const k4 = f(pendState.theta + dt * k3[0], pendState.omega + dt * k3[1]);

        pendState.theta += dt/6 * (k1[0] + 2*k2[0] + 2*k3[0] + k4[0]);
        pendState.omega += dt/6 * (k1[1] + 2*k2[1] + 2*k3[1] + k4[1]);

        pendTrail.push({ theta: pendState.theta, omega: pendState.omega });
        if (pendTrail.length > 300) pendTrail.shift();

        drawPendulum();
        drawPhaseSpace();
        pendAnimId = requestAnimationFrame(animatePendulum);
    }

    function drawPendulum() {
        const svg = document.getElementById('pendulum-viz');
        if (!svg) return;

        const size = 250;
        const cx = size / 2, cy = size / 2 - 20;
        const L = 80;

        svg.innerHTML = '';

        // Pivot
        const pivot = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
        pivot.setAttribute('cx', cx); pivot.setAttribute('cy', cy);
        pivot.setAttribute('r', 5); pivot.setAttribute('fill', '#888');
        svg.appendChild(pivot);

        // Rod
        const bobX = cx + L * Math.sin(pendState.theta);
        const bobY = cy + L * Math.cos(pendState.theta);

        const rod = document.createElementNS('http://www.w3.org/2000/svg', 'line');
        rod.setAttribute('x1', cx); rod.setAttribute('y1', cy);
        rod.setAttribute('x2', bobX); rod.setAttribute('y2', bobY);
        rod.setAttribute('stroke', '#ccc'); rod.setAttribute('stroke-width', 3);
        svg.appendChild(rod);

        // Bob
        const bob = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
        bob.setAttribute('cx', bobX); bob.setAttribute('cy', bobY);
        bob.setAttribute('r', 15); bob.setAttribute('fill', '#61afef');
        svg.appendChild(bob);
    }

    function drawPhaseSpace() {
        const svg = document.getElementById('phase-viz');
        if (!svg) return;

        const width = 400, height = 300;
        const margin = { top: 20, right: 20, bottom: 35, left: 45 };
        const plotW = width - margin.left - margin.right;
        const plotH = height - margin.top - margin.bottom;

        svg.innerHTML = '';

        const g = document.createElementNS('http://www.w3.org/2000/svg', 'g');
        g.setAttribute('transform', `translate(${margin.left}, ${margin.top})`);
        svg.appendChild(g);

        // Axes
        const xAxis = document.createElementNS('http://www.w3.org/2000/svg', 'line');
        xAxis.setAttribute('x1', 0); xAxis.setAttribute('y1', plotH / 2);
        xAxis.setAttribute('x2', plotW); xAxis.setAttribute('y2', plotH / 2);
        xAxis.setAttribute('stroke', '#666'); xAxis.setAttribute('stroke-width', 1);
        g.appendChild(xAxis);

        const yAxis = document.createElementNS('http://www.w3.org/2000/svg', 'line');
        yAxis.setAttribute('x1', plotW / 2); yAxis.setAttribute('y1', 0);
        yAxis.setAttribute('x2', plotW / 2); yAxis.setAttribute('y2', plotH);
        yAxis.setAttribute('stroke', '#666'); yAxis.setAttribute('stroke-width', 1);
        g.appendChild(yAxis);

        // Labels
        const xLabel = document.createElementNS('http://www.w3.org/2000/svg', 'text');
        xLabel.setAttribute('x', plotW); xLabel.setAttribute('y', plotH / 2 - 5);
        xLabel.setAttribute('fill', '#888'); xLabel.setAttribute('text-anchor', 'end');
        xLabel.setAttribute('font-size', '12px');
        xLabel.textContent = 'θ';
        g.appendChild(xLabel);

        const yLabel = document.createElementNS('http://www.w3.org/2000/svg', 'text');
        yLabel.setAttribute('x', plotW / 2 + 5); yLabel.setAttribute('y', 15);
        yLabel.setAttribute('fill', '#888'); yLabel.setAttribute('font-size', '12px');
        yLabel.textContent = 'ω';
        g.appendChild(yLabel);

        if (pendTrail.length < 2) return;

        const scale = plotW / (2 * Math.PI);
        const omegaScale = plotH / 20;

        // Trail
        let path = '';
        pendTrail.forEach((pt, i) => {
            const x = plotW / 2 + pt.theta * scale;
            const y = plotH / 2 - pt.omega * omegaScale;
            path += (i === 0 ? 'M' : 'L') + `${x},${y}`;
        });
        const curve = document.createElementNS('http://www.w3.org/2000/svg', 'path');
        curve.setAttribute('d', path);
        curve.setAttribute('stroke', '#98c379');
        curve.setAttribute('stroke-width', 2);
        curve.setAttribute('fill', 'none');
        g.appendChild(curve);

        // Current point
        const last = pendTrail[pendTrail.length - 1];
        const dot = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
        dot.setAttribute('cx', plotW / 2 + last.theta * scale);
        dot.setAttribute('cy', plotH / 2 - last.omega * omegaScale);
        dot.setAttribute('r', 5);
        dot.setAttribute('fill', '#e5c07b');
        g.appendChild(dot);
    }

    function drawPhaseFlow() {
        const svg = document.getElementById('phase-flow-viz');
        if (!svg) return;

        const width = 700, height = 350;
        const margin = { top: 20, right: 20, bottom: 40, left: 50 };
        const plotW = width - margin.left - margin.right;
        const plotH = height - margin.top - margin.bottom;

        svg.innerHTML = '';

        const g = document.createElementNS('http://www.w3.org/2000/svg', 'g');
        g.setAttribute('transform', `translate(${margin.left}, ${margin.top})`);
        svg.appendChild(g);

        // Axes
        const xAxis = document.createElementNS('http://www.w3.org/2000/svg', 'line');
        xAxis.setAttribute('x1', 0); xAxis.setAttribute('y1', plotH / 2);
        xAxis.setAttribute('x2', plotW); xAxis.setAttribute('y2', plotH / 2);
        xAxis.setAttribute('stroke', '#666'); xAxis.setAttribute('stroke-width', 1.5);
        g.appendChild(xAxis);

        const yAxis = document.createElementNS('http://www.w3.org/2000/svg', 'line');
        yAxis.setAttribute('x1', plotW / 2); yAxis.setAttribute('y1', 0);
        yAxis.setAttribute('x2', plotW / 2); yAxis.setAttribute('y2', plotH);
        yAxis.setAttribute('stroke', '#666'); yAxis.setAttribute('stroke-width', 1.5);
        g.appendChild(yAxis);

        // Labels
        const xLabel = document.createElementNS('http://www.w3.org/2000/svg', 'text');
        xLabel.setAttribute('x', plotW / 2); xLabel.setAttribute('y', plotH + 30);
        xLabel.setAttribute('fill', '#888'); xLabel.setAttribute('text-anchor', 'middle');
        xLabel.setAttribute('font-size', '14px');
        xLabel.textContent = 'θ';
        g.appendChild(xLabel);

        const yLabel = document.createElementNS('http://www.w3.org/2000/svg', 'text');
        yLabel.setAttribute('x', -plotH / 2); yLabel.setAttribute('y', -35);
        yLabel.setAttribute('fill', '#888'); yLabel.setAttribute('text-anchor', 'middle');
        yLabel.setAttribute('transform', 'rotate(-90)');
        yLabel.setAttribute('font-size', '14px');
        yLabel.textContent = 'dθ/dt';
        g.appendChild(yLabel);

        // Draw multiple trajectories
        const grav = 9.8, L = 1;
        const theta0s = [0.3, 0.6, 1.0, 1.5, 2.0, 2.5, 2.9];
        const colors = ['#61afef', '#98c379', '#e5c07b', '#e06c75', '#c678dd', '#56b6c2', '#abb2bf'];

        theta0s.forEach((th0, idx) => {
            let theta = th0, omega = 0;
            const dt = 0.02;
            let path = '';

            for (let i = 0; i < 500; i++) {
                const x = plotW / 2 + theta * (plotW / (2 * Math.PI));
                const y = plotH / 2 - omega * (plotH / 20);
                path += (i === 0 ? 'M' : 'L') + `${x},${y}`;

                // RK4 step
                const f = (th, om) => [om, -(grav/L) * Math.sin(th)];
                const k1 = f(theta, omega);
                const k2 = f(theta + dt/2 * k1[0], omega + dt/2 * k1[1]);
                const k3 = f(theta + dt/2 * k2[0], omega + dt/2 * k2[1]);
                const k4 = f(theta + dt * k3[0], omega + dt * k3[1]);
                theta += dt/6 * (k1[0] + 2*k2[0] + 2*k3[0] + k4[0]);
                omega += dt/6 * (k1[1] + 2*k2[1] + 2*k3[1] + k4[1]);
            }

            const curve = document.createElementNS('http://www.w3.org/2000/svg', 'path');
            curve.setAttribute('d', path);
            curve.setAttribute('stroke', colors[idx]);
            curve.setAttribute('stroke-width', 2);
            curve.setAttribute('fill', 'none');
            curve.setAttribute('opacity', '0.7');
            g.appendChild(curve);
        });
    }

    // ==========================================
    // PDE GRID VISUALIZATION
    // ==========================================
    let pdeGrid = [];
    let pdeTimeStep = 0;
    let pdeSpaceIdx = 1; // Current stencil position in space (1 to pdeNx-2)
    let pdeCurrentRow = []; // Row being built
    const pdeNx = 15;
    const pdeNt = 20;
    const pdeD = 0.4;
    const pdeDx = 1 / (pdeNx - 1);
    const pdeDt = 0.4 * pdeDx * pdeDx / pdeD;
    const pdeR = pdeD * pdeDt / (pdeDx * pdeDx);

    function initPDEGrid() {
        pdeGrid = [];
        pdeTimeStep = 0;
        pdeSpaceIdx = 1;
        pdeCurrentRow = [];

        // Initial condition: Gaussian
        const row = [];
        for (let i = 0; i < pdeNx; i++) {
            const x = i / (pdeNx - 1);
            row.push(Math.exp(-Math.pow((x - 0.5) * 5, 2)));
        }
        pdeGrid.push(row);
        pdeCurrentRow = [0]; // Start with BC

        drawPDEGrid();
        drawPDEColorbar();
        updatePDEFormula(null);
    }

    function pdeStepStencil() {
        if (pdeTimeStep >= pdeNt - 1) return;

        const prev = pdeGrid[pdeGrid.length - 1];

        if (pdeSpaceIdx < pdeNx - 1) {
            // Compute this cell
            const i = pdeSpaceIdx;
            const newVal = prev[i] + pdeR * (prev[i+1] - 2*prev[i] + prev[i-1]);
            pdeCurrentRow.push(newVal);

            // Update formula display
            updatePDEFormula({
                i: i,
                n: pdeTimeStep,
                uPrev: prev[i-1],
                uCurr: prev[i],
                uNext: prev[i+1],
                uNew: newVal,
                r: pdeR
            });

            pdeSpaceIdx++;
        }

        // Check if row is complete
        if (pdeSpaceIdx >= pdeNx - 1) {
            pdeCurrentRow.push(0); // Right BC
            pdeGrid.push([...pdeCurrentRow]);
            pdeTimeStep++;
            pdeSpaceIdx = 1;
            pdeCurrentRow = [0]; // Start new row with left BC
        }

        drawPDEGrid();
    }

    function pdeStepRow() {
        if (pdeTimeStep >= pdeNt - 1) return;

        // Complete the current row
        const prev = pdeGrid[pdeGrid.length - 1];
        pdeCurrentRow = [0]; // Left BC

        for (let i = 1; i < pdeNx - 1; i++) {
            pdeCurrentRow.push(prev[i] + pdeR * (prev[i+1] - 2*prev[i] + prev[i-1]));
        }
        pdeCurrentRow.push(0); // Right BC

        pdeGrid.push([...pdeCurrentRow]);
        pdeTimeStep++;
        pdeSpaceIdx = 1;
        pdeCurrentRow = [0];

        updatePDEFormula(null);
        drawPDEGrid();
    }

    function pdeStepBack() {
        if (pdeGrid.length <= 1) return;
        pdeGrid.pop();
        pdeTimeStep--;
        pdeSpaceIdx = 1;
        pdeCurrentRow = [0];
        updatePDEFormula(null);
        drawPDEGrid();
    }

    function pdeReset() {
        initPDEGrid();
    }

    function updatePDEFormula(data) {
        const box = document.getElementById('pde-formula-box');
        if (!box) return;

        if (!data) {
            box.innerHTML = `
                <div style="margin-bottom: 8px;"><strong>Current stencil:</strong></div>
                <div style="color: #888;">Click "Step Stencil" to begin...</div>
                <div style="margin-top: 10px; color: #61afef;">r = ${pdeR.toFixed(3)}</div>
            `;
        } else {
            box.innerHTML = `
                <div style="margin-bottom: 8px;"><strong>Computing $u_{${data.i}}^{${data.n+1}}$:</strong></div>
                <div style="font-size: 0.85em;">
                    $u_{${data.i}}^{${data.n+1}} = u_{${data.i}}^{${data.n}} + r(u_{${data.i+1}}^{${data.n}} - 2u_{${data.i}}^{${data.n}} + u_{${data.i-1}}^{${data.n}})$
                </div>
                <div style="margin-top: 8px; font-size: 0.85em;">
                    $= ${data.uCurr.toFixed(3)} + ${pdeR.toFixed(2)}(${data.uNext.toFixed(3)} - 2 \\cdot ${data.uCurr.toFixed(3)} + ${data.uPrev.toFixed(3)})$
                </div>
                <div style="margin-top: 8px; color: #98c379; font-size: 0.9em;">
                    $= ${data.uNew.toFixed(4)}$
                </div>
            `;
        }
    }

    function drawPDEColorbar() {
        const svg = document.getElementById('pde-colorbar');
        if (!svg) return;

        svg.innerHTML = '';
        const width = 200, height = 20;

        // Gradient bar
        for (let i = 0; i < width; i++) {
            const val = i / width;
            const intensity = Math.floor(val * 255);
            const rect = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
            rect.setAttribute('x', i);
            rect.setAttribute('y', 0);
            rect.setAttribute('width', 1);
            rect.setAttribute('height', height);
            rect.setAttribute('fill', `rgb(${intensity}, ${Math.floor(intensity * 0.7)}, ${255 - intensity})`);
            svg.appendChild(rect);
        }

        // Labels
        [0, 0.5, 1].forEach(val => {
            const x = val * width;
            const label = document.createElementNS('http://www.w3.org/2000/svg', 'text');
            label.setAttribute('x', x);
            label.setAttribute('y', height + 10);
            label.setAttribute('fill', '#888');
            label.setAttribute('text-anchor', val === 0 ? 'start' : (val === 1 ? 'end' : 'middle'));
            label.setAttribute('font-size', '9px');
            label.textContent = val.toFixed(1);
            svg.appendChild(label);
        });
    }

    function drawPDEGrid() {
        const svg = document.getElementById('pde-grid-viz');
        if (!svg) return;

        const width = 550, height = 320;
        const margin = { top: 30, right: 20, bottom: 50, left: 50 };
        const plotW = width - margin.left - margin.right;
        const plotH = height - margin.top - margin.bottom;

        svg.innerHTML = '';

        const g = document.createElementNS('http://www.w3.org/2000/svg', 'g');
        g.setAttribute('transform', `translate(${margin.left}, ${margin.top})`);
        svg.appendChild(g);

        const cellW = plotW / pdeNx;
        const cellH = plotH / pdeNt;

        // Draw completed grid cells
        for (let t = 0; t < pdeGrid.length; t++) {
            for (let i = 0; i < pdeNx; i++) {
                const val = pdeGrid[t][i];
                const rect = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
                rect.setAttribute('x', i * cellW);
                rect.setAttribute('y', plotH - (t + 1) * cellH);
                rect.setAttribute('width', cellW - 1);
                rect.setAttribute('height', cellH - 1);

                const intensity = Math.min(255, Math.floor(val * 255));
                rect.setAttribute('fill', `rgb(${intensity}, ${Math.floor(intensity * 0.7)}, ${255 - intensity})`);
                rect.setAttribute('stroke', 'rgba(255,255,255,0.1)');
                g.appendChild(rect);
            }
        }

        // Draw current row being built
        if (pdeCurrentRow.length > 0 && pdeTimeStep < pdeNt - 1) {
            const t = pdeGrid.length;
            for (let i = 0; i < pdeCurrentRow.length; i++) {
                const val = pdeCurrentRow[i];
                const rect = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
                rect.setAttribute('x', i * cellW);
                rect.setAttribute('y', plotH - (t + 1) * cellH);
                rect.setAttribute('width', cellW - 1);
                rect.setAttribute('height', cellH - 1);

                const intensity = Math.min(255, Math.floor(val * 255));
                rect.setAttribute('fill', `rgb(${intensity}, ${Math.floor(intensity * 0.7)}, ${255 - intensity})`);
                rect.setAttribute('stroke', '#98c379');
                rect.setAttribute('stroke-width', 2);
                g.appendChild(rect);
            }
        }

        // Highlight current stencil
        if (pdeTimeStep < pdeNt - 1 && pdeSpaceIdx < pdeNx - 1) {
            const t = pdeGrid.length - 1;
            const i = pdeSpaceIdx;

            // Source cells (previous row)
            [-1, 0, 1].forEach(di => {
                const rect = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
                rect.setAttribute('x', (i + di) * cellW);
                rect.setAttribute('y', plotH - (t + 1) * cellH);
                rect.setAttribute('width', cellW - 1);
                rect.setAttribute('height', cellH - 1);
                rect.setAttribute('fill', 'none');
                rect.setAttribute('stroke', '#61afef');
                rect.setAttribute('stroke-width', 2);
                g.appendChild(rect);
            });

            // Target cell
            const targetRect = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
            targetRect.setAttribute('x', i * cellW);
            targetRect.setAttribute('y', plotH - (t + 2) * cellH);
            targetRect.setAttribute('width', cellW - 1);
            targetRect.setAttribute('height', cellH - 1);
            targetRect.setAttribute('fill', 'rgba(152, 195, 121, 0.3)');
            targetRect.setAttribute('stroke', '#98c379');
            targetRect.setAttribute('stroke-width', 2);
            g.appendChild(targetRect);
        }

        // Axis labels
        const xLabel = document.createElementNS('http://www.w3.org/2000/svg', 'text');
        xLabel.setAttribute('x', plotW / 2); xLabel.setAttribute('y', plotH + 35);
        xLabel.setAttribute('fill', '#888'); xLabel.setAttribute('text-anchor', 'middle');
        xLabel.setAttribute('font-size', '12px');
        xLabel.textContent = 'Space index i';
        g.appendChild(xLabel);

        const yLabel = document.createElementNS('http://www.w3.org/2000/svg', 'text');
        yLabel.setAttribute('x', -plotH / 2); yLabel.setAttribute('y', -35);
        yLabel.setAttribute('fill', '#888'); yLabel.setAttribute('text-anchor', 'middle');
        yLabel.setAttribute('transform', 'rotate(-90)');
        yLabel.setAttribute('font-size', '12px');
        yLabel.textContent = 'Time step n';
        g.appendChild(yLabel);

        // Status
        const stepText = document.createElementNS('http://www.w3.org/2000/svg', 'text');
        stepText.setAttribute('x', plotW - 5); stepText.setAttribute('y', -10);
        stepText.setAttribute('fill', '#ccc'); stepText.setAttribute('text-anchor', 'end');
        stepText.setAttribute('font-size', '11px');
        stepText.textContent = `n=${pdeTimeStep}, i=${pdeSpaceIdx}`;
        g.appendChild(stepText);
    }

    // ==========================================
    // CFL STABILITY DEMONSTRATION
    // ==========================================
    function initCFLDemo() {
        drawCFLDemo();
    }

    function runCFLDemo() {
        const r = parseFloat(document.getElementById('cfl-r')?.value || 0.4);
        document.getElementById('cfl-r-val').textContent = r.toFixed(2);

        // Run simulation
        const nx = 30;
        const nt = 50;
        let u = [];

        // Initial condition: Gaussian
        for (let i = 0; i < nx; i++) {
            const x = i / (nx - 1);
            u.push(Math.exp(-Math.pow((x - 0.5) * 5, 2)));
        }

        const history = [u.slice()];

        for (let n = 0; n < nt; n++) {
            const uNew = [0]; // Left BC
            for (let i = 1; i < nx - 1; i++) {
                const val = u[i] + r * (u[i+1] - 2*u[i] + u[i-1]);
                uNew.push(val);
            }
            uNew.push(0); // Right BC
            u = uNew;
            history.push(u.slice());

            // Check for blowup
            const maxU = Math.max(...u.map(Math.abs));
            if (maxU > 100) break;
        }

        drawCFLDemo(history, r);

        // Update status
        const statusBox = document.getElementById('cfl-status');
        if (r <= 0.5) {
            statusBox.className = 'success-box small-text';
            statusBox.innerHTML = `<strong>r = ${r.toFixed(2)}:</strong> Stable ✓<br>Solution remains bounded`;
        } else {
            statusBox.className = 'warning-box small-text';
            statusBox.innerHTML = `<strong>r = ${r.toFixed(2)}:</strong> UNSTABLE ✗<br>Solution blows up!`;
        }
    }

    function drawCFLDemo(history, r) {
        const svg = document.getElementById('cfl-demo-viz');
        if (!svg) return;

        const width = 400, height = 280;
        const margin = { top: 20, right: 20, bottom: 40, left: 45 };
        const plotW = width - margin.left - margin.right;
        const plotH = height - margin.top - margin.bottom;

        svg.innerHTML = '';

        const g = document.createElementNS('http://www.w3.org/2000/svg', 'g');
        g.setAttribute('transform', `translate(${margin.left}, ${margin.top})`);
        svg.appendChild(g);

        // Axes
        const xAxis = document.createElementNS('http://www.w3.org/2000/svg', 'line');
        xAxis.setAttribute('x1', 0); xAxis.setAttribute('y1', plotH);
        xAxis.setAttribute('x2', plotW); xAxis.setAttribute('y2', plotH);
        xAxis.setAttribute('stroke', '#666'); xAxis.setAttribute('stroke-width', 1);
        g.appendChild(xAxis);

        const yAxis = document.createElementNS('http://www.w3.org/2000/svg', 'line');
        yAxis.setAttribute('x1', 0); yAxis.setAttribute('y1', 0);
        yAxis.setAttribute('x2', 0); yAxis.setAttribute('y2', plotH);
        yAxis.setAttribute('stroke', '#666'); yAxis.setAttribute('stroke-width', 1);
        g.appendChild(yAxis);

        // Labels
        const xLabel = document.createElementNS('http://www.w3.org/2000/svg', 'text');
        xLabel.setAttribute('x', plotW / 2); xLabel.setAttribute('y', plotH + 30);
        xLabel.setAttribute('fill', '#888'); xLabel.setAttribute('text-anchor', 'middle');
        xLabel.setAttribute('font-size', '11px');
        xLabel.textContent = 'Space (x)';
        g.appendChild(xLabel);

        const yLabel = document.createElementNS('http://www.w3.org/2000/svg', 'text');
        yLabel.setAttribute('x', -plotH / 2); yLabel.setAttribute('y', -30);
        yLabel.setAttribute('fill', '#888'); yLabel.setAttribute('text-anchor', 'middle');
        yLabel.setAttribute('transform', 'rotate(-90)');
        yLabel.setAttribute('font-size', '11px');
        yLabel.textContent = 'u(x,t)';
        g.appendChild(yLabel);

        if (!history) return;

        const nx = history[0].length;
        const yMax = r > 0.5 ? 5 : 1.2;
        const yMin = r > 0.5 ? -5 : -0.2;

        // Draw several time slices
        const colors = ['#61afef', '#98c379', '#e5c07b', '#e06c75', '#c678dd'];
        const times = [0, Math.floor(history.length * 0.25), Math.floor(history.length * 0.5),
                       Math.floor(history.length * 0.75), history.length - 1];

        times.forEach((t, idx) => {
            if (t >= history.length) return;
            const u = history[t];
            let path = '';

            u.forEach((val, i) => {
                const px = (i / (nx - 1)) * plotW;
                const py = plotH - ((Math.min(Math.max(val, yMin), yMax) - yMin) / (yMax - yMin)) * plotH;
                path += (i === 0 ? 'M' : 'L') + `${px},${py}`;
            });

            const curve = document.createElementNS('http://www.w3.org/2000/svg', 'path');
            curve.setAttribute('d', path);
            curve.setAttribute('stroke', colors[idx]);
            curve.setAttribute('stroke-width', 1.5);
            curve.setAttribute('fill', 'none');
            curve.setAttribute('opacity', idx === times.length - 1 ? 1 : 0.5);
            g.appendChild(curve);
        });

        // Zero line
        if (r > 0.5) {
            const zeroY = plotH - ((0 - yMin) / (yMax - yMin)) * plotH;
            const zeroLine = document.createElementNS('http://www.w3.org/2000/svg', 'line');
            zeroLine.setAttribute('x1', 0); zeroLine.setAttribute('y1', zeroY);
            zeroLine.setAttribute('x2', plotW); zeroLine.setAttribute('y2', zeroY);
            zeroLine.setAttribute('stroke', '#888'); zeroLine.setAttribute('stroke-dasharray', '4,4');
            g.appendChild(zeroLine);
        }
    }

    // ==========================================
    // 2D FLUID SIMULATOR
    // ==========================================
    let fluidCanvas, fluidCtx;
    let fluidN = 64;
    let fluidDt = 0.1;
    let fluidDiff = 0.0001;
    let fluidVisc = 0.0001;
    let fluidU, fluidV, fluidU0, fluidV0;
    let fluidDens, fluidDens0;
    let fluidMouseX = 0, fluidMouseY = 0, fluidPMouseX = 0, fluidPMouseY = 0;
    let fluidAnimId = null;

    function IX(i, j) { return i + (fluidN + 2) * j; }

    function initFluid() {
        fluidCanvas = document.getElementById('fluid-canvas');
        if (!fluidCanvas) return;
        fluidCtx = fluidCanvas.getContext('2d');

        const size = (fluidN + 2) * (fluidN + 2);
        fluidU = new Float32Array(size);
        fluidV = new Float32Array(size);
        fluidU0 = new Float32Array(size);
        fluidV0 = new Float32Array(size);
        fluidDens = new Float32Array(size);
        fluidDens0 = new Float32Array(size);

        fluidCanvas.addEventListener('mousemove', (e) => {
            const rect = fluidCanvas.getBoundingClientRect();
            fluidPMouseX = fluidMouseX;
            fluidPMouseY = fluidMouseY;
            fluidMouseX = (e.clientX - rect.left) / rect.width;
            fluidMouseY = (e.clientY - rect.top) / rect.height;
        });

        if (fluidAnimId) cancelAnimationFrame(fluidAnimId);
        animateFluid();
    }

    function addSource(x, s, dt) {
        for (let i = 0; i < x.length; i++) x[i] += dt * s[i];
    }

    function setBnd(b, x) {
        for (let i = 1; i <= fluidN; i++) {
            x[IX(0, i)] = b === 1 ? -x[IX(1, i)] : x[IX(1, i)];
            x[IX(fluidN + 1, i)] = b === 1 ? -x[IX(fluidN, i)] : x[IX(fluidN, i)];
            x[IX(i, 0)] = b === 2 ? -x[IX(i, 1)] : x[IX(i, 1)];
            x[IX(i, fluidN + 1)] = b === 2 ? -x[IX(i, fluidN)] : x[IX(i, fluidN)];
        }
        x[IX(0, 0)] = 0.5 * (x[IX(1, 0)] + x[IX(0, 1)]);
        x[IX(0, fluidN + 1)] = 0.5 * (x[IX(1, fluidN + 1)] + x[IX(0, fluidN)]);
        x[IX(fluidN + 1, 0)] = 0.5 * (x[IX(fluidN, 0)] + x[IX(fluidN + 1, 1)]);
        x[IX(fluidN + 1, fluidN + 1)] = 0.5 * (x[IX(fluidN, fluidN + 1)] + x[IX(fluidN + 1, fluidN)]);
    }

    function linSolve(b, x, x0, a, c) {
        for (let k = 0; k < 4; k++) {
            for (let i = 1; i <= fluidN; i++) {
                for (let j = 1; j <= fluidN; j++) {
                    x[IX(i, j)] = (x0[IX(i, j)] + a * (x[IX(i - 1, j)] + x[IX(i + 1, j)] + x[IX(i, j - 1)] + x[IX(i, j + 1)])) / c;
                }
            }
            setBnd(b, x);
        }
    }

    function diffuse(b, x, x0, diff, dt) {
        const a = dt * diff * fluidN * fluidN;
        linSolve(b, x, x0, a, 1 + 4 * a);
    }

    function advect(b, d, d0, u, v, dt) {
        const dt0 = dt * fluidN;
        for (let i = 1; i <= fluidN; i++) {
            for (let j = 1; j <= fluidN; j++) {
                let x = i - dt0 * u[IX(i, j)];
                let y = j - dt0 * v[IX(i, j)];
                x = Math.max(0.5, Math.min(fluidN + 0.5, x));
                y = Math.max(0.5, Math.min(fluidN + 0.5, y));
                const i0 = Math.floor(x), i1 = i0 + 1;
                const j0 = Math.floor(y), j1 = j0 + 1;
                const s1 = x - i0, s0 = 1 - s1;
                const t1 = y - j0, t0 = 1 - t1;
                d[IX(i, j)] = s0 * (t0 * d0[IX(i0, j0)] + t1 * d0[IX(i0, j1)]) + s1 * (t0 * d0[IX(i1, j0)] + t1 * d0[IX(i1, j1)]);
            }
        }
        setBnd(b, d);
    }

    function project(u, v, p, div) {
        for (let i = 1; i <= fluidN; i++) {
            for (let j = 1; j <= fluidN; j++) {
                div[IX(i, j)] = -0.5 * (u[IX(i + 1, j)] - u[IX(i - 1, j)] + v[IX(i, j + 1)] - v[IX(i, j - 1)]) / fluidN;
                p[IX(i, j)] = 0;
            }
        }
        setBnd(0, div);
        setBnd(0, p);
        linSolve(0, p, div, 1, 4);
        for (let i = 1; i <= fluidN; i++) {
            for (let j = 1; j <= fluidN; j++) {
                u[IX(i, j)] -= 0.5 * fluidN * (p[IX(i + 1, j)] - p[IX(i - 1, j)]);
                v[IX(i, j)] -= 0.5 * fluidN * (p[IX(i, j + 1)] - p[IX(i, j - 1)]);
            }
        }
        setBnd(1, u);
        setBnd(2, v);
    }

    function velStep(u, v, u0, v0, visc, dt) {
        addSource(u, u0, dt);
        addSource(v, v0, dt);
        [u0, u] = [u, u0];
        diffuse(1, u, u0, visc, dt);
        [v0, v] = [v, v0];
        diffuse(2, v, v0, visc, dt);
        project(u, v, u0, v0);
        [u0, u] = [u, u0];
        [v0, v] = [v, v0];
        advect(1, u, u0, u0, v0, dt);
        advect(2, v, v0, u0, v0, dt);
        project(u, v, u0, v0);
    }

    function densStep(x, x0, u, v, diff, dt) {
        addSource(x, x0, dt);
        [x0, x] = [x, x0];
        diffuse(0, x, x0, diff, dt);
        [x0, x] = [x, x0];
        advect(0, x, x0, u, v, dt);
    }

    function animateFluid() {
        // Clear sources
        fluidU0.fill(0);
        fluidV0.fill(0);
        fluidDens0.fill(0);

        // Add mouse force
        const i = Math.floor(fluidMouseX * fluidN) + 1;
        const j = Math.floor(fluidMouseY * fluidN) + 1;
        if (i > 0 && i <= fluidN && j > 0 && j <= fluidN) {
            fluidU0[IX(i, j)] = (fluidMouseX - fluidPMouseX) * 1000;
            fluidV0[IX(i, j)] = (fluidMouseY - fluidPMouseY) * 1000;
            fluidDens0[IX(i, j)] = 50;
        }

        // Add constant source at top
        for (let ii = fluidN / 4; ii < 3 * fluidN / 4; ii++) {
            fluidDens0[IX(ii, fluidN - 2)] += 5;
            fluidV0[IX(ii, fluidN - 2)] = -5;
        }

        velStep(fluidU, fluidV, fluidU0, fluidV0, fluidVisc, fluidDt);
        densStep(fluidDens, fluidDens0, fluidU, fluidV, fluidDiff, fluidDt);

        drawFluid();
        fluidAnimId = requestAnimationFrame(animateFluid);
    }

    function drawFluid() {
        if (!fluidCtx) return;

        const w = fluidCanvas.width;
        const h = fluidCanvas.height;
        const cellW = w / fluidN;
        const cellH = h / fluidN;

        const imgData = fluidCtx.createImageData(w, h);

        for (let i = 0; i < fluidN; i++) {
            for (let j = 0; j < fluidN; j++) {
                const d = Math.min(255, fluidDens[IX(i + 1, j + 1)] * 5);

                const x0 = Math.floor(i * cellW);
                const y0 = Math.floor(j * cellH);
                const x1 = Math.floor((i + 1) * cellW);
                const y1 = Math.floor((j + 1) * cellH);

                for (let x = x0; x < x1; x++) {
                    for (let y = y0; y < y1; y++) {
                        const idx = (y * w + x) * 4;
                        imgData.data[idx] = d * 0.4;
                        imgData.data[idx + 1] = d * 0.6;
                        imgData.data[idx + 2] = d;
                        imgData.data[idx + 3] = 255;
                    }
                }
            }
        }

        fluidCtx.putImageData(imgData, 0, 0);
    }

    // ==========================================
    // LORENZ SYSTEM
    // ==========================================
    let lorenzTrails = [];
    let lorenzAnimId = null;

    function initLorenz() {
        lorenzTrails = [{ x: 1, y: 1, z: 1, color: '#61afef', trail: [] }];
        if (lorenzAnimId) cancelAnimationFrame(lorenzAnimId);
        animateLorenz();
    }

    function animateLorenz() {
        const sigma = 10, rho = 28, beta = 8/3;
        const dt = 0.005;

        lorenzTrails.forEach(traj => {
            for (let step = 0; step < 5; step++) {
                const dx = sigma * (traj.y - traj.x);
                const dy = traj.x * (rho - traj.z) - traj.y;
                const dz = traj.x * traj.y - beta * traj.z;

                traj.x += dx * dt;
                traj.y += dy * dt;
                traj.z += dz * dt;

                traj.trail.push({ x: traj.x, y: traj.y, z: traj.z });
                if (traj.trail.length > 1000) traj.trail.shift();
            }
        });

        drawLorenz();
        lorenzAnimId = requestAnimationFrame(animateLorenz);
    }

    function drawLorenz() {
        const svg = document.getElementById('lorenz-viz');
        if (!svg) return;

        const width = 500, height = 400;
        svg.innerHTML = '';

        lorenzTrails.forEach(traj => {
            if (traj.trail.length < 2) return;

            let path = '';
            traj.trail.forEach((pt, i) => {
                // Simple 3D to 2D projection
                const scale = 6;
                const x = width / 2 + pt.x * scale;
                const y = height - 50 - pt.z * scale * 0.8;
                path += (i === 0 ? 'M' : 'L') + `${x},${y}`;
            });

            const curve = document.createElementNS('http://www.w3.org/2000/svg', 'path');
            curve.setAttribute('d', path);
            curve.setAttribute('stroke', traj.color);
            curve.setAttribute('stroke-width', 1.5);
            curve.setAttribute('fill', 'none');
            curve.setAttribute('opacity', '0.8');
            svg.appendChild(curve);
        });

        // Label
        const label = document.createElementNS('http://www.w3.org/2000/svg', 'text');
        label.setAttribute('x', 10); label.setAttribute('y', 25);
        label.setAttribute('fill', '#888'); label.setAttribute('font-size', '12px');
        label.textContent = 'Lorenz Attractor (x-z projection)';
        svg.appendChild(label);
    }

    function resetLorenz() {
        if (lorenzAnimId) cancelAnimationFrame(lorenzAnimId);
        initLorenz();
    }

    function perturbLorenz() {
        const eps = Math.pow(10, parseFloat(document.getElementById('lorenz-perturb')?.value || -4));
        const base = lorenzTrails[0];
        lorenzTrails.push({
            x: base.x + eps,
            y: base.y,
            z: base.z,
            color: '#e06c75',
            trail: []
        });
    }

    function initLorenzSensitivity() {
        const svg = document.getElementById('lorenz-sensitivity-viz');
        if (!svg) return;

        updateLorenzSensitivity();
    }

    function updateLorenzSensitivity() {
        const svg = document.getElementById('lorenz-sensitivity-viz');
        if (!svg) return;

        const exp = parseFloat(document.getElementById('lorenz-perturb')?.value || -4);
        const eps = Math.pow(10, exp);
        document.getElementById('lorenz-perturb-val').textContent = `10^{${exp}}`;

        const width = 800, height = 350;
        const margin = { top: 20, right: 20, bottom: 40, left: 50 };
        const plotW = width - margin.left - margin.right;
        const plotH = height - margin.top - margin.bottom;

        svg.innerHTML = '';

        const g = document.createElementNS('http://www.w3.org/2000/svg', 'g');
        g.setAttribute('transform', `translate(${margin.left}, ${margin.top})`);
        svg.appendChild(g);

        // Simulate two trajectories
        const sigma = 10, rho = 28, beta = 8/3;
        const dt = 0.01;
        const steps = 3000;

        let x1 = 1, y1 = 1, z1 = 1;
        let x2 = 1 + eps, y2 = 1, z2 = 1;

        const traj1 = [], traj2 = [];

        for (let i = 0; i < steps; i++) {
            if (i % 5 === 0) {
                traj1.push({ t: i * dt, x: x1 });
                traj2.push({ t: i * dt, x: x2 });
            }

            // RK4 for traj1
            const f1 = (x, y, z) => [sigma * (y - x), x * (rho - z) - y, x * y - beta * z];
            let k1 = f1(x1, y1, z1);
            let k2 = f1(x1 + dt/2 * k1[0], y1 + dt/2 * k1[1], z1 + dt/2 * k1[2]);
            let k3 = f1(x1 + dt/2 * k2[0], y1 + dt/2 * k2[1], z1 + dt/2 * k2[2]);
            let k4 = f1(x1 + dt * k3[0], y1 + dt * k3[1], z1 + dt * k3[2]);
            x1 += dt/6 * (k1[0] + 2*k2[0] + 2*k3[0] + k4[0]);
            y1 += dt/6 * (k1[1] + 2*k2[1] + 2*k3[1] + k4[1]);
            z1 += dt/6 * (k1[2] + 2*k2[2] + 2*k3[2] + k4[2]);

            // RK4 for traj2
            k1 = f1(x2, y2, z2);
            k2 = f1(x2 + dt/2 * k1[0], y2 + dt/2 * k1[1], z2 + dt/2 * k1[2]);
            k3 = f1(x2 + dt/2 * k2[0], y2 + dt/2 * k2[1], z2 + dt/2 * k2[2]);
            k4 = f1(x2 + dt * k3[0], y2 + dt * k3[1], z2 + dt * k3[2]);
            x2 += dt/6 * (k1[0] + 2*k2[0] + 2*k3[0] + k4[0]);
            y2 += dt/6 * (k1[1] + 2*k2[1] + 2*k3[1] + k4[1]);
            z2 += dt/6 * (k1[2] + 2*k2[2] + 2*k3[2] + k4[2]);
        }

        // Axes
        const xAxis = document.createElementNS('http://www.w3.org/2000/svg', 'line');
        xAxis.setAttribute('x1', 0); xAxis.setAttribute('y1', plotH / 2);
        xAxis.setAttribute('x2', plotW); xAxis.setAttribute('y2', plotH / 2);
        xAxis.setAttribute('stroke', '#666'); xAxis.setAttribute('stroke-width', 1);
        g.appendChild(xAxis);

        // Labels
        const xLabel = document.createElementNS('http://www.w3.org/2000/svg', 'text');
        xLabel.setAttribute('x', plotW / 2); xLabel.setAttribute('y', plotH + 30);
        xLabel.setAttribute('fill', '#888'); xLabel.setAttribute('text-anchor', 'middle');
        xLabel.setAttribute('font-size', '12px');
        xLabel.textContent = 'Time';
        g.appendChild(xLabel);

        const yLabel = document.createElementNS('http://www.w3.org/2000/svg', 'text');
        yLabel.setAttribute('x', -plotH / 2); yLabel.setAttribute('y', -35);
        yLabel.setAttribute('fill', '#888'); yLabel.setAttribute('text-anchor', 'middle');
        yLabel.setAttribute('transform', 'rotate(-90)');
        yLabel.setAttribute('font-size', '12px');
        yLabel.textContent = 'x(t)';
        g.appendChild(yLabel);

        const tMax = traj1[traj1.length - 1].t;
        const xScale = plotW / tMax;
        const yScale = plotH / 50;

        // Draw trajectories
        [{ data: traj1, color: '#61afef' }, { data: traj2, color: '#e06c75' }].forEach(({ data, color }) => {
            let path = '';
            data.forEach((pt, i) => {
                const px = pt.t * xScale;
                const py = plotH / 2 - pt.x * yScale;
                path += (i === 0 ? 'M' : 'L') + `${px},${py}`;
            });
            const curve = document.createElementNS('http://www.w3.org/2000/svg', 'path');
            curve.setAttribute('d', path);
            curve.setAttribute('stroke', color);
            curve.setAttribute('stroke-width', 1.5);
            curve.setAttribute('fill', 'none');
            g.appendChild(curve);
        });
    }

    // ==========================================
    // EULER STEP-BY-STEP INTEGRATION
    // ==========================================
    let eulerState = { x: 0, v: 15, t: 0 };
    let eulerHistory = [];
    const eulerG = 9.8;
    const eulerX0 = 0;
    const eulerV0 = 15;

    function initEuler() {
        eulerState = { x: eulerX0, v: eulerV0, t: 0 };
        eulerHistory = [{ t: 0, x: eulerX0, v: eulerV0 }];
        drawEulerPlot();
        updateEulerComputation(null);
    }

    function eulerStep() {
        const dt = parseFloat(document.getElementById('euler-dt')?.value || 0.2);
        document.getElementById('euler-dt-val').textContent = dt.toFixed(2);

        const n = eulerHistory.length - 1;
        const prev = eulerHistory[n];

        // Euler update
        const v_new = prev.v - eulerG * dt;
        const x_new = prev.x + prev.v * dt;
        const t_new = prev.t + dt;

        eulerState = { x: x_new, v: v_new, t: t_new };
        eulerHistory.push({ t: t_new, x: x_new, v: v_new });

        drawEulerPlot();
        updateEulerComputation({ n, prev, dt, v_new, x_new, t_new });
    }

    function eulerReset() {
        initEuler();
    }

    function updateEulerComputation(stepData) {
        const container = document.getElementById('euler-computation');
        if (!container) return;

        if (!stepData) {
            container.innerHTML = `
                <div style="margin-bottom: 10px;"><strong>Initial conditions:</strong></div>
                <div>$x_0 = 0$ m</div>
                <div>$v_0 = 15$ m/s (upward)</div>
                <div>$g = 9.8$ m/s²</div>
                <div style="margin-top: 15px; color: #888;">Click "Step" to begin...</div>
            `;
        } else {
            const { n, prev, dt, v_new, x_new, t_new } = stepData;
            container.innerHTML = `
                <div style="margin-bottom: 8px;"><strong>Step ${n} → ${n + 1}:</strong> ($\\Delta t = ${dt.toFixed(2)}$s)</div>
                <div style="color: #e5c07b;">$v_{${n+1}} = v_{${n}} - g \\cdot \\Delta t$</div>
                <div style="margin-left: 20px;">$= ${prev.v.toFixed(2)} - 9.8 \\times ${dt.toFixed(2)}$</div>
                <div style="margin-left: 20px; color: var(--accent-cyan);">$= ${v_new.toFixed(2)}$ m/s</div>
                <div style="margin-top: 10px; color: #e5c07b;">$x_{${n+1}} = x_{${n}} + v_{${n}} \\cdot \\Delta t$</div>
                <div style="margin-left: 20px;">$= ${prev.x.toFixed(2)} + ${prev.v.toFixed(2)} \\times ${dt.toFixed(2)}$</div>
                <div style="margin-left: 20px; color: var(--accent-green);">$= ${x_new.toFixed(2)}$ m</div>
                <div style="margin-top: 10px; color: #888;">$t = ${t_new.toFixed(2)}$ s</div>
            `;
        }
        // Re-render KaTeX
        if (typeof renderMathInElement !== 'undefined') {
            renderMathInElement(container, {
                delimiters: [
                    {left: '$$', right: '$$', display: true},
                    {left: '$', right: '$', display: false}
                ]
            });
        }
    }

    function drawEulerPlot() {
        const svg = document.getElementById('euler-plot');
        if (!svg) return;

        const width = 480, height = 300;
        const margin = { top: 20, right: 20, bottom: 40, left: 50 };
        const plotW = width - margin.left - margin.right;
        const plotH = height - margin.top - margin.bottom;

        svg.innerHTML = '';

        const g = document.createElementNS('http://www.w3.org/2000/svg', 'g');
        g.setAttribute('transform', `translate(${margin.left}, ${margin.top})`);
        svg.appendChild(g);

        // Calculate time range for the ball trajectory (time to return to ground)
        const tFlight = 2 * eulerV0 / eulerG; // Total flight time analytically
        const tMax = Math.max(tFlight * 1.1, eulerHistory[eulerHistory.length - 1]?.t || tFlight);
        const xMax = eulerV0 * eulerV0 / (2 * eulerG) * 1.3; // Max height + margin

        // Axes
        const xAxis = document.createElementNS('http://www.w3.org/2000/svg', 'line');
        xAxis.setAttribute('x1', 0); xAxis.setAttribute('y1', plotH);
        xAxis.setAttribute('x2', plotW); xAxis.setAttribute('y2', plotH);
        xAxis.setAttribute('stroke', '#666'); xAxis.setAttribute('stroke-width', 1.5);
        g.appendChild(xAxis);

        const yAxis = document.createElementNS('http://www.w3.org/2000/svg', 'line');
        yAxis.setAttribute('x1', 0); yAxis.setAttribute('y1', 0);
        yAxis.setAttribute('x2', 0); yAxis.setAttribute('y2', plotH);
        yAxis.setAttribute('stroke', '#666'); yAxis.setAttribute('stroke-width', 1.5);
        g.appendChild(yAxis);

        // Labels
        const xLabel = document.createElementNS('http://www.w3.org/2000/svg', 'text');
        xLabel.setAttribute('x', plotW / 2); xLabel.setAttribute('y', plotH + 30);
        xLabel.setAttribute('fill', '#888'); xLabel.setAttribute('text-anchor', 'middle');
        xLabel.setAttribute('font-size', '12px');
        xLabel.textContent = 'Time (s)';
        g.appendChild(xLabel);

        const yLabel = document.createElementNS('http://www.w3.org/2000/svg', 'text');
        yLabel.setAttribute('x', -plotH / 2); yLabel.setAttribute('y', -35);
        yLabel.setAttribute('fill', '#888'); yLabel.setAttribute('text-anchor', 'middle');
        yLabel.setAttribute('transform', 'rotate(-90)');
        yLabel.setAttribute('font-size', '12px');
        yLabel.textContent = 'Height x(t) (m)';
        g.appendChild(yLabel);

        // Draw analytical solution (dashed green line)
        let analyticalPath = '';
        const nPoints = 100;
        for (let i = 0; i <= nPoints; i++) {
            const t = (i / nPoints) * tMax;
            const x_analytical = eulerX0 + eulerV0 * t - 0.5 * eulerG * t * t;
            const px = (t / tMax) * plotW;
            const py = plotH - (Math.max(0, x_analytical) / xMax) * plotH;
            analyticalPath += (i === 0 ? 'M' : 'L') + `${px},${py}`;
        }
        const analyticalCurve = document.createElementNS('http://www.w3.org/2000/svg', 'path');
        analyticalCurve.setAttribute('d', analyticalPath);
        analyticalCurve.setAttribute('stroke', '#98c379');
        analyticalCurve.setAttribute('stroke-width', 2);
        analyticalCurve.setAttribute('stroke-dasharray', '8,4');
        analyticalCurve.setAttribute('fill', 'none');
        g.appendChild(analyticalCurve);

        // Draw numerical solution (blue dots and lines)
        if (eulerHistory.length > 1) {
            let numPath = '';
            eulerHistory.forEach((pt, i) => {
                const px = (pt.t / tMax) * plotW;
                const py = plotH - (Math.max(0, pt.x) / xMax) * plotH;
                numPath += (i === 0 ? 'M' : 'L') + `${px},${py}`;
            });
            const numCurve = document.createElementNS('http://www.w3.org/2000/svg', 'path');
            numCurve.setAttribute('d', numPath);
            numCurve.setAttribute('stroke', '#61afef');
            numCurve.setAttribute('stroke-width', 2);
            numCurve.setAttribute('fill', 'none');
            g.appendChild(numCurve);
        }

        // Draw points
        eulerHistory.forEach((pt, i) => {
            const px = (pt.t / tMax) * plotW;
            const py = plotH - (Math.max(0, pt.x) / xMax) * plotH;

            const dot = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
            dot.setAttribute('cx', px);
            dot.setAttribute('cy', py);
            dot.setAttribute('r', 6);
            dot.setAttribute('fill', '#61afef');
            dot.setAttribute('stroke', '#fff');
            dot.setAttribute('stroke-width', 1);
            g.appendChild(dot);

            // Label for point
            const label = document.createElementNS('http://www.w3.org/2000/svg', 'text');
            label.setAttribute('x', px);
            label.setAttribute('y', py - 10);
            label.setAttribute('fill', '#ccc');
            label.setAttribute('text-anchor', 'middle');
            label.setAttribute('font-size', '10px');
            label.textContent = i.toString();
            g.appendChild(label);
        });

        // Ground line
        const ground = document.createElementNS('http://www.w3.org/2000/svg', 'line');
        ground.setAttribute('x1', 0); ground.setAttribute('y1', plotH);
        ground.setAttribute('x2', plotW); ground.setAttribute('y2', plotH);
        ground.setAttribute('stroke', '#888'); ground.setAttribute('stroke-width', 2);
        ground.setAttribute('stroke-dasharray', '4,2');
        g.appendChild(ground);

        // Tick marks on axes
        for (let i = 0; i <= 4; i++) {
            const t = (i / 4) * tMax;
            const px = (t / tMax) * plotW;
            const tick = document.createElementNS('http://www.w3.org/2000/svg', 'line');
            tick.setAttribute('x1', px); tick.setAttribute('y1', plotH);
            tick.setAttribute('x2', px); tick.setAttribute('y2', plotH + 5);
            tick.setAttribute('stroke', '#888');
            g.appendChild(tick);

            const tickLabel = document.createElementNS('http://www.w3.org/2000/svg', 'text');
            tickLabel.setAttribute('x', px); tickLabel.setAttribute('y', plotH + 15);
            tickLabel.setAttribute('fill', '#888'); tickLabel.setAttribute('text-anchor', 'middle');
            tickLabel.setAttribute('font-size', '10px');
            tickLabel.textContent = t.toFixed(1);
            g.appendChild(tickLabel);
        }

        for (let i = 0; i <= 4; i++) {
            const x = (i / 4) * xMax;
            const py = plotH - (x / xMax) * plotH;
            const tick = document.createElementNS('http://www.w3.org/2000/svg', 'line');
            tick.setAttribute('x1', 0); tick.setAttribute('y1', py);
            tick.setAttribute('x2', -5); tick.setAttribute('y2', py);
            tick.setAttribute('stroke', '#888');
            g.appendChild(tick);

            const tickLabel = document.createElementNS('http://www.w3.org/2000/svg', 'text');
            tickLabel.setAttribute('x', -8); tickLabel.setAttribute('y', py + 3);
            tickLabel.setAttribute('fill', '#888'); tickLabel.setAttribute('text-anchor', 'end');
            tickLabel.setAttribute('font-size', '10px');
            tickLabel.textContent = x.toFixed(1);
            g.appendChild(tickLabel);
        }
    }

    // ==========================================
    // INITIALIZATION
    // ==========================================
    Reveal.on('slidechanged', event => {
        // Euler step-by-step
        if (event.currentSlide.querySelector('#euler-plot')) {
            initEuler();
        }

        // Hudson Bay data
        if (event.currentSlide.querySelector('#hudson-data-viz')) {
            drawHudsonData();
        }

        // Predator-prey fitting
        if (event.currentSlide.querySelector('#predprey-fit-viz')) {
            initPredPreyFit();
        }

        // Pendulum
        if (event.currentSlide.querySelector('#pendulum-viz')) {
            initPendulum();
        } else if (pendAnimId) {
            cancelAnimationFrame(pendAnimId);
        }

        // Phase flow
        if (event.currentSlide.querySelector('#phase-flow-viz')) {
            drawPhaseFlow();
        }

        // PDE Grid
        if (event.currentSlide.querySelector('#pde-grid-viz')) {
            initPDEGrid();
        }

        // CFL Demo
        if (event.currentSlide.querySelector('#cfl-demo-viz')) {
            initCFLDemo();
        }

        // Fluid
        if (event.currentSlide.querySelector('#fluid-canvas')) {
            initFluid();
        } else if (fluidAnimId) {
            cancelAnimationFrame(fluidAnimId);
        }

        // Lorenz
        if (event.currentSlide.querySelector('#lorenz-viz')) {
            initLorenz();
        } else if (lorenzAnimId) {
            cancelAnimationFrame(lorenzAnimId);
        }

        // Lorenz sensitivity
        if (event.currentSlide.querySelector('#lorenz-sensitivity-viz')) {
            initLorenzSensitivity();
        }
    });

    // Slider listeners
    document.addEventListener('DOMContentLoaded', () => {
        document.getElementById('euler-dt')?.addEventListener('input', () => {
            document.getElementById('euler-dt-val').textContent = parseFloat(document.getElementById('euler-dt').value).toFixed(2);
        });
        // Predator-prey fitting sliders
        document.getElementById('pp-alpha')?.addEventListener('input', drawPredPreyFit);
        document.getElementById('pp-beta')?.addEventListener('input', drawPredPreyFit);
        document.getElementById('pp-delta')?.addEventListener('input', drawPredPreyFit);
        document.getElementById('pp-gamma')?.addEventListener('input', drawPredPreyFit);
        // Pendulum
        document.getElementById('pend-theta0')?.addEventListener('input', () => {
            if (pendAnimId) cancelAnimationFrame(pendAnimId);
            initPendulum();
        });
        // CFL slider
        document.getElementById('cfl-r')?.addEventListener('input', () => {
            document.getElementById('cfl-r-val').textContent = parseFloat(document.getElementById('cfl-r').value).toFixed(2);
        });
        document.getElementById('lorenz-perturb')?.addEventListener('input', updateLorenzSensitivity);
    });
</script>
</body>
</html>
