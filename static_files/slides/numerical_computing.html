<!doctype html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Numerical Computing and Scientific Simulation</title>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/reveal.js@4.5.0/dist/reset.css">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/reveal.js@4.5.0/dist/reveal.css">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/reveal.js@4.5.0/dist/theme/night.css">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/reveal.js@4.5.0/plugin/highlight/monokai.css">
    <style>
        :root {
            --accent-blue: #61afef;
            --accent-green: #98c379;
            --accent-yellow: #e5c07b;
            --accent-red: #e06c75;
            --accent-purple: #c678dd;
            --accent-cyan: #56b6c2;
        }
        .reveal h1, .reveal h2, .reveal h3 { text-transform: none; }
        .reveal h1 { font-size: 2.2em; }
        .reveal h2 { font-size: 1.6em; }
        .reveal h3 { font-size: 1.3em; }
        .reveal blockquote {
            font-style: italic;
            background: rgba(255,255,255,0.05);
            padding: 20px 30px;
            border-left: 4px solid #42affa;
            width: 90%;
            margin: 0 auto;
            border-radius: 0 8px 8px 0;
        }
        .reveal .slides section { text-align: left; }
        .reveal ul { display: block; }
        .reveal li { margin: 0.5em 0; font-size: 0.85em; }
        .center-text { text-align: center; }
        .highlight-box {
            background: rgba(66, 175, 250, 0.15);
            padding: 15px 20px;
            border-radius: 8px;
            margin: 15px 0;
            border: 1px solid rgba(66, 175, 250, 0.3);
        }
        .warning-box {
            background: rgba(224, 108, 117, 0.15);
            padding: 15px 20px;
            border-radius: 8px;
            margin: 15px 0;
            border: 1px solid rgba(224, 108, 117, 0.3);
        }
        .success-box {
            background: rgba(152, 195, 121, 0.15);
            padding: 15px 20px;
            border-radius: 8px;
            margin: 15px 0;
            border: 1px solid rgba(152, 195, 121, 0.3);
        }
        .principle-box {
            background: rgba(198, 120, 221, 0.15);
            padding: 15px 20px;
            border-radius: 8px;
            margin: 15px 0;
            border: 1px solid rgba(198, 120, 221, 0.3);
        }
        .small-text { font-size: 0.75em; }
        .tiny-text { font-size: 0.65em; }
        pre code { font-size: 0.65em !important; line-height: 1.4 !important; }
        .reveal pre { width: 100%; box-shadow: 0 5px 15px rgba(0,0,0,0.3); }
        .two-column { display: flex; gap: 30px; align-items: flex-start; }
        .two-column > div { flex: 1; }
        .three-column { display: flex; gap: 20px; }
        .three-column > div { flex: 1; }
        .equation-box {
            background: rgba(255,255,255,0.08);
            padding: 12px 15px;
            border-radius: 8px;
            text-align: center;
            margin: 10px 0;
            font-size: 0.85em;
        }
        .equation-box.large { font-size: 1em; }
        .equation-box.small { font-size: 0.75em; }
        table.comparison {
            width: 100%;
            border-collapse: collapse;
            font-size: 0.8em;
        }
        table.comparison th, table.comparison td {
            padding: 12px;
            border: 1px solid rgba(255,255,255,0.2);
        }
        table.comparison th {
            background: rgba(66, 175, 250, 0.2);
        }
        .bowtie-diagram {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 10px;
            margin: 20px 0;
        }
        .bowtie-box {
            padding: 15px 25px;
            border-radius: 8px;
            text-align: center;
            font-weight: bold;
        }
        .bowtie-arrow {
            font-size: 2em;
            color: #888;
        }
        .stencil-grid {
            display: inline-grid;
            grid-template-columns: repeat(3, 65px);
            gap: 4px;
        }
        .stencil-cell {
            width: 65px;
            height: 38px;
            border: 2px solid #444;
            border-radius: 4px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 0.48em;
        }
        .stencil-active { background: rgba(97, 175, 239, 0.5); border-color: #61afef; }
        .stencil-target { background: rgba(152, 195, 121, 0.5); border-color: #98c379; }
        .stencil-inactive { background: rgba(255,255,255,0.05); }
        .slider-container {
            display: flex;
            align-items: center;
            gap: 10px;
            margin: 5px 0;
        }
        .slider-container label {
            min-width: 80px;
            font-size: 0.8em;
        }
        .slider-container input[type="range"] {
            flex: 1;
        }
        .slider-container span {
            min-width: 50px;
            font-size: 0.8em;
            color: var(--accent-blue);
        }
    </style>
</head>
<body>
<div class="reveal">
<div class="slides">

<!-- ============================================ -->
<!-- TITLE SLIDE -->
<!-- ============================================ -->
<section class="center-text">
    <h1>Numerical Computing</h1>
    <h2>and Scientific Simulation</h2>
    <p style="margin-top: 40px; color: #888;">ML for Science - Lecture 5</p>
    <p class="small-text" style="color: #666;">From differential equations to predictions on a computer</p>
</section>

<!-- ============================================ -->
<!-- LEARNING VS INFERENCE -->
<!-- ============================================ -->
<section>
    <section>
        <h2>The Big Picture: Learning vs Inference</h2>
        <div class="bowtie-diagram">
            <div class="bowtie-box" style="background: rgba(97, 175, 239, 0.3);">
                <div>Data</div>
                <div class="tiny-text">(high complexity)</div>
            </div>
            <div class="bowtie-arrow">&rarr;</div>
            <div class="bowtie-box" style="background: rgba(198, 120, 221, 0.3);">
                <div>Model</div>
                <div class="tiny-text">(low complexity)</div>
            </div>
            <div class="bowtie-arrow">&rarr;</div>
            <div class="bowtie-box" style="background: rgba(152, 195, 121, 0.3);">
                <div>Predictions</div>
                <div class="tiny-text">(high complexity)</div>
            </div>
        </div>
        <div class="two-column fragment" style="margin-top: 30px;">
            <div class="highlight-box small-text" style="text-align: center;">
                <strong style="color: var(--accent-blue);">Learning</strong><br>
                Data &rarr; Model<br>
                Compression / Distillation<br>
                Statistical
            </div>
            <div class="success-box small-text" style="text-align: center;">
                <strong style="color: var(--accent-green);">Inference</strong><br>
                Model &rarr; Predictions<br>
                Reconstruction / Generation<br>
                Computational / Recursive
            </div>
        </div>
    </section>

    <section>
        <h2>Today: From Models to Predictions</h2>
        <p>We've seen how to extract models from data (learning/fitting).</p>
        <p class="fragment">Now: <strong>How do we use models to make predictions?</strong></p>
        <div class="fragment principle-box" style="margin-top: 20px;">
            <strong>Key insight:</strong> Both learning and inference require computing, but they're fundamentally different:
            <ul class="small-text" style="margin-top: 10px;">
                <li><strong>Learning:</strong> Compress many observations into simple rules</li>
                <li><strong>Inference:</strong> Apply rules recursively to generate predictions</li>
            </ul>
        </div>
    </section>
</section>

<!-- ============================================ -->
<!-- COMPUTING AS RECURSION -->
<!-- ============================================ -->
<section>
    <section>
        <h2>Computing as Recursive Rule Application</h2>
        <p class="small-text">The most basic form of computing: <strong>apply a rule repeatedly</strong></p>
        <div class="fragment" style="margin-top: 10px;">
            <p class="small-text" style="color: var(--accent-purple); margin-bottom: 5px;"><strong>Peano Axioms: Generating Natural Numbers</strong></p>
            <div class="equation-box tiny-text" style="padding: 8px;">
                $0, \; S(0), \; S(S(0)), \; S(S(S(0))), \; \ldots$
            </div>
            <p class="tiny-text" style="margin-top: 5px;">Start with 0, apply successor function S repeatedly &rarr; all natural numbers</p>
        </div>
        <div class="fragment" style="margin-top: 10px;">
            <p class="small-text">This is just a <strong>for loop</strong>:</p>
            <pre style="font-size: 0.55em;"><code class="python">i = 0
for _ in range(n):
    i = i + 1  # successor</code></pre>
        </div>
    </section>

    <section>
        <h2>Example: Fibonacci Sequence</h2>
        <div class="equation-box">
            $F_n = F_{n-1} + F_{n-2}$
        </div>
        <p class="small-text">Simple rule &rarr; Complex, interesting sequence</p>
        <div class="two-column" style="margin-top: 20px;">
            <div>
                <pre><code class="python">def fib(n):
    a, b = 0, 1
    for _ in range(n):
        a, b = b, a + b
    return a</code></pre>
            </div>
            <div class="fragment">
                <p class="small-text">Properties emerge:</p>
                <ul class="tiny-text">
                    <li>Ratios converge to golden ratio $\phi$</li>
                    <li>Which are prime? Even?</li>
                    <li>Open questions in number theory!</li>
                </ul>
            </div>
        </div>
        <div class="fragment highlight-box small-text" style="margin-top: 15px;">
            <strong>Pattern:</strong> Simple recursive rule &rarr; Generate sequence &rarr; Ask questions about properties
        </div>
    </section>

    <section>
        <h2>Historical Example: Titius-Bode Law</h2>
        <p class="small-text">Planetary distances follow a pattern:</p>
        <div class="equation-box small-text">
            $a_n = 0.4 + 0.3 \times 2^n$ (in AU)
        </div>
        <div class="fragment" style="margin-top: 15px;">
            <p class="small-text">The process:</p>
            <ol class="small-text">
                <li>Observe data (planetary distances)</li>
                <li>Find the rule (the formula)</li>
                <li><strong>Use the rule to predict</strong> &rarr; missing planet?</li>
            </ol>
        </div>
        <div class="fragment success-box small-text" style="margin-top: 15px;">
            This predicted the asteroid belt and helped discover Uranus!
        </div>
    </section>

    <section>
        <h2>Cellular Automata: Game of Life</h2>
        <p class="tiny-text">Von Neumann's idea (1940s) + Conway's rules (1970): simple local rules ‚Üí complex emergent behavior</p>
        <div class="two-column" style="margin-top: 5px; align-items: flex-start;">
            <div style="flex: 1.5;">
                <canvas id="life-canvas" width="580" height="420" style="border-radius: 8px; background: #1a1a2e; cursor: crosshair;"></canvas>
                <p class="tiny-text center-text" style="color: #888; margin-top: 3px;">Click cells to toggle | Generation: <span id="life-gen">0</span></p>
            </div>
            <div style="flex: 0.8;">
                <div class="highlight-box tiny-text" style="padding: 8px;">
                    <strong>Rules (each cell):</strong>
                    <ul style="margin: 3px 0 0 12px; padding: 0; font-size: 0.9em;">
                        <li>Alive + 2-3 neighbors ‚Üí <span style="color: #98c379;">survives</span></li>
                        <li>Alive + &lt;2 neighbors ‚Üí <span style="color: #e06c75;">dies</span></li>
                        <li>Alive + &gt;3 neighbors ‚Üí <span style="color: #e06c75;">dies</span></li>
                        <li>Dead + 3 neighbors ‚Üí <span style="color: #98c379;">born</span></li>
                    </ul>
                </div>
                <div style="margin-top: 10px; display: flex; flex-wrap: wrap; gap: 6px; justify-content: center;">
                    <button id="life-step" style="padding: 4px 10px; font-size: 0.65em;">Step</button>
                    <button id="life-play" style="padding: 4px 10px; font-size: 0.65em;">‚ñ∂ Play</button>
                    <button id="life-reset" style="padding: 4px 10px; font-size: 0.65em;">Reset</button>
                    <select id="life-pattern" style="padding: 4px; font-size: 0.65em;">
                        <option value="glider">Glider</option>
                        <option value="blinker">Blinker</option>
                        <option value="glider-gun">Glider Gun</option>
                        <option value="random">Random</option>
                    </select>
                </div>
                <div class="fragment principle-box tiny-text" style="margin-top: 10px; padding: 6px;">
                    <strong>Turing complete!</strong> Can simulate any computation.
                </div>
            </div>
        </div>
    </section>
</section>

<!-- ============================================ -->
<!-- DIFFERENTIAL EQUATIONS TO DISCRETE -->
<!-- ============================================ -->
<section>
    <section>
        <h2>From Differential Equations to Discrete</h2>
        <p>Recall Galileo's projectile: $\displaystyle\frac{d^2x}{dt^2} = -g$</p>
        <p class="fragment">We integrated analytically: $x(t) = -\frac{1}{2}gt^2 + v_0 t + x_0$</p>
        <div class="fragment warning-box" style="margin-top: 20px;">
            <strong>Problem:</strong> Most equations can't be integrated analytically!
        </div>
        <p class="fragment" style="margin-top: 15px;"><strong>Solution:</strong> Solve on a computer by going back to discrete</p>
    </section>

    <section>
        <h2>Discretization</h2>
        <p>Turn derivatives back into differences:</p>
        <div class="equation-box">
            $\frac{dx}{dt} \approx \frac{x_{n+1} - x_n}{\Delta t}$
        </div>
        <div class="fragment" style="margin-top: 20px;">
            <p>For $\frac{d^2x}{dt^2} = -g$, introduce velocity $v = \frac{dx}{dt}$:</p>
            <div class="two-column small-text">
                <div class="equation-box">
                    $v_{n+1} = v_n - g \cdot \Delta t$
                </div>
                <div class="equation-box">
                    $x_{n+1} = x_n + v_n \cdot \Delta t$
                </div>
            </div>
        </div>
        <div class="fragment highlight-box small-text" style="margin-top: 15px;">
            Like Fibonacci: given previous values, compute the next one recursively!
        </div>
    </section>

    <section>
        <h2>Interactive: Step-by-Step Integration</h2>
        <div class="two-column">
            <div style="flex: 1.2;">
                <svg id="euler-plot" width="480" height="300" style="background: rgba(0,0,0,0.2); border-radius: 8px;"></svg>
                <div style="display: flex; gap: 15px; margin-top: 10px; flex-wrap: wrap;">
                    <div class="slider-container">
                        <label>Œît</label>
                        <input type="range" id="euler-dt" min="0.05" max="0.5" step="0.05" value="0.2">
                        <span id="euler-dt-val">0.20</span>
                    </div>
                    <button onclick="eulerStep()" id="euler-step-btn" style="padding: 5px 15px; cursor: pointer; border-radius: 4px; border: none; background: #61afef; color: white;">Step</button>
                    <button onclick="eulerReset()" style="padding: 5px 15px; cursor: pointer; border-radius: 4px; border: none; background: #e06c75; color: white;">Reset</button>
                </div>
            </div>
            <div style="flex: 1;">
                <div id="euler-computation" class="highlight-box small-text" style="min-height: 200px; font-family: monospace;">
                    <div style="margin-bottom: 10px;"><strong>Initial conditions:</strong></div>
                    <div>$x_0 = 0$ m</div>
                    <div>$v_0 = 15$ m/s (upward)</div>
                    <div>$g = 9.8$ m/s¬≤</div>
                    <div style="margin-top: 15px; color: #888;">Click "Step" to begin...</div>
                </div>
            </div>
        </div>
        <p class="tiny-text center-text" style="margin-top: 10px; color: #888;">
            <span style="color: #61afef;">Blue dots</span> = Numerical (Euler) |
            <span style="color: #98c379;">Green dashed</span> = Analytical solution
        </p>
    </section>

    <section>
        <h2>The Role of $\Delta t$</h2>
        <p>$\Delta t$ controls the <strong>accuracy</strong> of the approximation</p>
        <ul class="small-text">
            <li class="fragment">Smaller $\Delta t$ &rarr; more accurate, but slower</li>
            <li class="fragment">Larger $\Delta t$ &rarr; faster, but less accurate</li>
            <li class="fragment">Too large &rarr; solution can become <strong>unstable</strong>!</li>
        </ul>
        <div class="fragment principle-box small-text" style="margin-top: 20px;">
            <strong>Key trade-off:</strong> Speed vs Accuracy
        </div>
    </section>
</section>

<!-- ============================================ -->
<!-- PREDATOR-PREY -->
<!-- ============================================ -->
<section>
    <section>
        <h2>Case Study: The Hudson Bay Fur Records</h2>
        <div class="two-column">
            <div>
                <p class="small-text"><strong>The Fur Trade Business:</strong></p>
                <ul class="tiny-text">
                    <li><strong>1670-1920s:</strong> Hudson's Bay Company was a fur trading giant</li>
                    <li>Beaver and lynx pelts were highly prized for European fashion</li>
                    <li>Company kept detailed ledgers of pelts purchased from trappers</li>
                    <li><strong>Why track pelts?</strong> Inventory, pricing, trapper payments</li>
                </ul>
                <div class="fragment highlight-box tiny-text" style="margin-top: 10px;">
                    <strong>1924:</strong> Ecologist Charles Elton analyzed 90 years of pelt records<br>
                    Discovered striking ~10-year cycles in lynx and hare populations
                </div>
                <div class="fragment principle-box tiny-text" style="margin-top: 10px;">
                    <strong>The puzzle:</strong> Why do populations oscillate so regularly?
                </div>
            </div>
            <div>
                <div style="display: flex; gap: 20px; margin-bottom: 15px; justify-content: center;">
                    <div style="text-align: center;">
                        <svg width="120" height="80" style="border-radius: 8px; border: 2px solid #61afef; background: rgba(97,175,239,0.1);">
                            <text x="60" y="35" text-anchor="middle" fill="#61afef" font-size="28">üê∞</text>
                            <text x="60" y="58" text-anchor="middle" fill="#61afef" font-size="10">Snowshoe</text>
                            <text x="60" y="70" text-anchor="middle" fill="#61afef" font-size="10">Hare</text>
                        </svg>
                    </div>
                    <div style="text-align: center;">
                        <svg width="120" height="80" style="border-radius: 8px; border: 2px solid #e06c75; background: rgba(224,108,117,0.1);">
                            <text x="60" y="35" text-anchor="middle" fill="#e06c75" font-size="28">üê±</text>
                            <text x="60" y="58" text-anchor="middle" fill="#e06c75" font-size="10">Canadian</text>
                            <text x="60" y="70" text-anchor="middle" fill="#e06c75" font-size="10">Lynx</text>
                        </svg>
                    </div>
                </div>
                <svg id="hudson-data-viz" width="420" height="220" style="background: rgba(0,0,0,0.2); border-radius: 8px;"></svg>
                <p class="tiny-text" style="text-align: center; color: #888;">
                    Hudson Bay Company records (1900-1920)<br>
                    <span style="color: #61afef;">‚ñ† Hare</span> | <span style="color: #e06c75;">‚ñ† Lynx</span> (thousands)
                </p>
            </div>
        </div>
    </section>

    <section>
        <h2>The Lotka-Volterra Model</h2>
        <p class="small-text">Lotka (1925) and Volterra (1926) independently proposed:</p>
        <div class="two-column" style="margin-top: 15px;">
            <div>
                <p class="small-text"><strong>The logic:</strong></p>
                <ul class="tiny-text">
                    <li class="fragment">More prey &rarr; predators thrive</li>
                    <li class="fragment">More predators &rarr; eat more prey</li>
                    <li class="fragment">Fewer prey &rarr; predators starve</li>
                    <li class="fragment">Fewer predators &rarr; prey recover</li>
                    <li class="fragment">&rarr; <strong>Oscillation!</strong></li>
                </ul>
            </div>
            <div>
                <div class="equation-box small-text">
                    $\displaystyle\frac{dx}{dt} = \color{#98c379}{\alpha}\, x - \color{#e5c07b}{\beta}\, xy$<br><br>
                    $\displaystyle\frac{dy}{dt} = \color{#c678dd}{\delta}\, xy - \color{#56b6c2}{\gamma}\, y$
                </div>
                <p class="tiny-text" style="margin-top: 10px;">
                    $x$ = prey (hares), $y$ = predators (lynx)<br>
                    $\color{#98c379}{\alpha}$ = prey growth |
                    $\color{#e5c07b}{\beta}$ = predation rate<br>
                    $\color{#c678dd}{\delta}$ = predator efficiency |
                    $\color{#56b6c2}{\gamma}$ = predator death
                </p>
            </div>
        </div>
    </section>

    <section>
        <h2>Discretizing the Equations</h2>
        <p class="small-text">Apply Euler's method to each equation:</p>
        <div class="two-column" style="margin-top: 15px;">
            <div>
                <div class="highlight-box tiny-text" style="padding: 12px;">
                    <strong>Continuous:</strong><br>
                    $\frac{dx}{dt} = \alpha x - \beta xy$<br><br>
                    $\frac{dy}{dt} = \delta xy - \gamma y$
                </div>
            </div>
            <div>
                <div class="success-box tiny-text" style="padding: 12px;">
                    <strong>Discrete (Euler):</strong><br>
                    $x_{n+1} = x_n + \Delta t (\alpha x_n - \beta x_n y_n)$<br><br>
                    $y_{n+1} = y_n + \Delta t (\delta x_n y_n - \gamma y_n)$
                </div>
            </div>
        </div>
        <div class="fragment principle-box tiny-text" style="margin-top: 20px;">
            <strong>The recipe:</strong> Given $(x_n, y_n)$ at time $t_n$, compute $(x_{n+1}, y_{n+1})$ at time $t_{n+1} = t_n + \Delta t$
        </div>
    </section>

    <section>
        <h2>Fitting the Model to Data</h2>
        <div class="two-column">
            <div style="flex: 1.5;">
                <svg id="predprey-fit-viz" width="550" height="320" style="background: rgba(0,0,0,0.2); border-radius: 8px;"></svg>
            </div>
            <div style="flex: 1;">
                <div class="equation-box tiny-text" style="padding: 10px;">
                    $\displaystyle\frac{dx}{dt} = \color{#98c379}{\alpha}\, x - \color{#e5c07b}{\beta}\, xy$<br><br>
                    $\displaystyle\frac{dy}{dt} = \color{#c678dd}{\delta}\, xy - \color{#56b6c2}{\gamma}\, y$
                </div>
                <div style="margin-top: 10px;">
                    <div class="slider-container">
                        <label style="color: #98c379;">Œ±:</label>
                        <input type="range" id="pp-alpha" min="0.2" max="1.0" step="0.02" value="0.55">
                        <span id="pp-alpha-val" style="color: #98c379;">0.55</span>
                    </div>
                    <div class="slider-container">
                        <label style="color: #e5c07b;">Œ≤:</label>
                        <input type="range" id="pp-beta" min="0.01" max="0.1" step="0.005" value="0.028">
                        <span id="pp-beta-val" style="color: #e5c07b;">0.028</span>
                    </div>
                    <div class="slider-container">
                        <label style="color: #c678dd;">Œ¥:</label>
                        <input type="range" id="pp-delta" min="0.005" max="0.05" step="0.002" value="0.018">
                        <span id="pp-delta-val" style="color: #c678dd;">0.018</span>
                    </div>
                    <div class="slider-container">
                        <label style="color: #56b6c2;">Œ≥:</label>
                        <input type="range" id="pp-gamma" min="0.2" max="1.2" step="0.02" value="0.84">
                        <span id="pp-gamma-val" style="color: #56b6c2;">0.84</span>
                    </div>
                </div>
                <button onclick="resetPredPreyFit()" style="margin-top: 10px; padding: 5px 15px; cursor: pointer; border-radius: 4px; border: none; background: #61afef; color: white; width: 100%;">Reset Parameters</button>
            </div>
        </div>
        <p class="tiny-text center-text" style="margin-top: 5px; color: #888;">
            Dots = Real data | Lines = Model simulation |
            <span style="color: #61afef;">Hare</span> | <span style="color: #e06c75;">Lynx</span>
        </p>
    </section>
</section>

<!-- ============================================ -->
<!-- PENDULUM -->
<!-- ============================================ -->
<section>
    <section>
        <h2>Case Study: The Pendulum</h2>
        <p>The equation of motion:</p>
        <div class="equation-box">
            $\displaystyle\frac{d^2\theta}{dt^2} = -\frac{g}{L}\sin\theta$
        </div>
        <div class="fragment" style="margin-top: 20px;">
            <p class="small-text">For small angles: $\sin\theta \approx \theta$ &rarr; simple harmonic motion</p>
            <p class="small-text">For large angles: <strong>nonlinear!</strong> Must solve numerically.</p>
        </div>
    </section>

    <section>
        <h2>Discretizing the Pendulum</h2>
        <p class="small-text">Introduce angular velocity $\omega = \frac{d\theta}{dt}$, then apply Euler:</p>
        <div class="two-column" style="margin-top: 15px;">
            <div>
                <div class="highlight-box small-text">
                    <strong>Continuous:</strong><br>
                    $\displaystyle\frac{d\theta}{dt} = \omega$<br><br>
                    $\displaystyle\frac{d\omega}{dt} = -\frac{g}{L}\sin\theta$
                </div>
            </div>
            <div>
                <div class="success-box small-text">
                    <strong>Discrete (Euler):</strong><br>
                    $\theta_{n+1} = \theta_n + \Delta t \cdot \omega_n$<br><br>
                    $\omega_{n+1} = \omega_n - \Delta t \cdot \frac{g}{L}\sin\theta_n$
                </div>
            </div>
        </div>
        <div class="fragment principle-box small-text" style="margin-top: 20px;">
            <strong>Same pattern:</strong> Given $(\theta_n, \omega_n)$ at time $t_n$, compute $(\theta_{n+1}, \omega_{n+1})$ at $t_{n+1} = t_n + \Delta t$
        </div>
    </section>

    <section>
        <h2>Pendulum Phase Space</h2>
        <div class="two-column">
            <div>
                <svg id="pendulum-viz" width="250" height="250" style="background: rgba(0,0,0,0.2); border-radius: 8px;"></svg>
                <div class="slider-container" style="margin-top: 10px;">
                    <label style="min-width: 30px;">Œ∏‚ÇÄ:</label>
                    <input type="range" id="pend-theta0" min="0.1" max="3.0" step="0.1" value="0.5">
                    <span id="pend-theta0-val">0.5</span>
                </div>
            </div>
            <div>
                <svg id="phase-viz" width="400" height="300" style="background: rgba(0,0,0,0.2); border-radius: 8px;"></svg>
            </div>
        </div>
        <p class="tiny-text center-text" style="margin-top: 10px;">
            Left: Pendulum animation | Right: Phase space (Œ∏, œâ)
        </p>
    </section>

    <section>
        <h2>Phase Space: The Full Picture</h2>
        <div style="display: flex; justify-content: center;">
            <svg id="phase-flow-viz" width="700" height="350" style="background: rgba(0,0,0,0.2); border-radius: 8px;"></svg>
        </div>
        <p class="small-text center-text" style="margin-top: 10px;">
            Multiple trajectories in phase space for different initial conditions
        </p>
        <p class="tiny-text center-text" style="color: #7ee8f3;">
            Small Œ∏‚ÇÄ: circles | Large Œ∏‚ÇÄ: distorted "eye" shapes
        </p>
    </section>
</section>

<!-- ============================================ -->
<!-- ERROR ANALYSIS -->
<!-- ============================================ -->
<section>
    <section>
        <h2>Error Analysis: How Accurate?</h2>
        <p class="small-text">Unlike Fibonacci (exact), numerical solutions have <strong>error</strong>. Use <strong>Taylor expansion</strong>:</p>
        <div class="fragment equation-box" style="padding: 10px; font-size: 0.75em;">
            $x(t + \Delta t) = x(t) + \Delta t \cdot \dot{x}(t) + \frac{(\Delta t)^2}{2}\ddot{x}(t) + O((\Delta t)^3)$
        </div>
        <div class="fragment" style="margin-top: 10px;">
            <p class="tiny-text">Rearranging for the derivative:</p>
            <div class="equation-box" style="padding: 10px; font-size: 0.7em;">
                $\frac{x(t + \Delta t) - x(t)}{\Delta t} = \dot{x}(t) + \underbrace{\frac{\Delta t}{2}\ddot{x}(t) + O((\Delta t)^2)}_{\text{Error} = O(\Delta t)}$
            </div>
        </div>
        <p class="fragment tiny-text" style="margin-top: 8px; color: #98c379;">
            <strong>Key insight:</strong> Euler method has error $O(\Delta t)$ ‚Äî halving step size halves the error
        </p>
    </section>

    <section>
        <h2>Finite Difference Schemes</h2>
        <div class="three-column small-text">
            <div class="highlight-box" style="text-align: center;">
                <strong>Forward</strong><br>
                $\displaystyle\frac{x_{n+1} - x_n}{\Delta t}$<br><br>
                Error: $O(\Delta t)$
            </div>
            <div class="highlight-box" style="text-align: center;">
                <strong>Backward</strong><br>
                $\displaystyle\frac{x_n - x_{n-1}}{\Delta t}$<br><br>
                Error: $O(\Delta t)$
            </div>
            <div class="success-box" style="text-align: center;">
                <strong>Central</strong><br>
                $\displaystyle\frac{x_{n+1} - x_{n-1}}{2\Delta t}$<br><br>
                Error: $O((\Delta t)^2)$
            </div>
        </div>
        <p class="fragment small-text" style="margin-top: 20px; text-align: center;">
            Central difference is more accurate for the same $\Delta t$!
        </p>
    </section>

    <section>
        <h2>Second Derivative</h2>
        <div class="equation-box">
            $\frac{d^2 x}{dt^2} \approx \frac{x_{n+1} - 2x_n + x_{n-1}}{(\Delta t)^2}$
        </div>
        <p class="small-text" style="margin-top: 15px;">Error: $O((\Delta t)^2)$</p>
        <div class="fragment highlight-box small-text" style="margin-top: 20px;">
            <strong>The pattern:</strong> Higher-order schemes = more neighbors used = better accuracy = more computation
        </div>
    </section>
</section>

<!-- ============================================ -->
<!-- PDEs: DIFFUSION -->
<!-- ============================================ -->
<section>
    <section>
        <h2>PDEs: Functions of Space AND Time</h2>
        <p>Now $u(x, t)$ depends on both space and time</p>
        <div class="equation-box">
            <strong>Diffusion Equation:</strong> $\displaystyle\frac{\partial u}{\partial t} = D\frac{\partial^2 u}{\partial x^2}$
        </div>
        <div class="fragment" style="margin-top: 20px;">
            <p class="small-text"><strong>Examples where diffusion appears:</strong></p>
            <ul class="tiny-text">
                <li><strong>Heat conduction:</strong> Temperature spreads through a material</li>
                <li><strong>Chemical diffusion:</strong> Ink spreading in water, pollutants in air</li>
                <li><strong>Electrical signals:</strong> Current spreading in neural axons</li>
                <li><strong>Population dynamics:</strong> Species spreading into new territory</li>
                <li><strong>Information:</strong> Rumors spreading through a network</li>
            </ul>
        </div>
    </section>

    <section>
        <h2>Discretizing Space and Time</h2>
        <p class="small-text">Define a grid with spacing $\Delta x$ in space and $\Delta t$ in time:</p>
        <div class="equation-box" style="margin-top: 10px; font-size: 0.8em; padding: 10px;">
            $u_i^n \equiv u(x_i, t_n)$ where $x_i = i \cdot \Delta x$ and $t_n = n \cdot \Delta t$
        </div>
        <div class="fragment" style="margin-top: 15px;">
            <p class="tiny-text">Apply finite differences to both derivatives:</p>
            <div class="two-column" style="margin-top: 8px; font-size: 0.7em;">
                <div class="highlight-box" style="text-align: center; padding: 10px;">
                    <strong>Time:</strong> $\frac{\partial u}{\partial t} \approx \frac{u_i^{n+1} - u_i^n}{\Delta t}$
                </div>
                <div class="highlight-box" style="text-align: center; padding: 10px;">
                    <strong>Space:</strong> $\frac{\partial^2 u}{\partial x^2} \approx \frac{u_{i+1}^n - 2u_i^n + u_{i-1}^n}{(\Delta x)^2}$
                </div>
            </div>
        </div>
        <div class="fragment success-box" style="margin-top: 12px; font-size: 0.7em; padding: 10px;">
            <strong>Update rule:</strong> $u_i^{n+1} = u_i^n + r(u_{i+1}^n - 2u_i^n + u_{i-1}^n)$ &nbsp; where $r = D\frac{\Delta t}{(\Delta x)^2}$
        </div>
    </section>

    <section>
        <h2>PDE Discretization: Step by Step</h2>
        <div class="two-column">
            <div style="flex: 1.3;">
                <svg id="pde-grid-viz" width="550" height="320" style="background: rgba(0,0,0,0.2); border-radius: 8px;"></svg>
            </div>
            <div style="flex: 0.7;">
                <div id="pde-formula-box" class="highlight-box tiny-text" style="min-height: 120px; font-family: monospace;">
                    <div style="margin-bottom: 8px;"><strong>Current stencil:</strong></div>
                    <div style="color: #888;">Click "Step" to begin...</div>
                </div>
                <div style="margin-top: 10px;">
                    <svg id="pde-colorbar" width="200" height="30"></svg>
                    <p class="tiny-text" style="margin: 0; color: #888;">u value (0 to 1)</p>
                </div>
            </div>
        </div>
        <div style="text-align: center; margin-top: 10px;">
            <button onclick="pdeStepBack()" style="padding: 5px 15px; margin: 0 5px; cursor: pointer; border-radius: 4px; border: none; background: #666; color: white;">‚Üê Back</button>
            <button onclick="pdeStepStencil()" style="padding: 5px 15px; margin: 0 5px; cursor: pointer; border-radius: 4px; border: none; background: #61afef; color: white;">Step Stencil ‚Üí</button>
            <button onclick="pdeStepRow()" style="padding: 5px 15px; margin: 0 5px; cursor: pointer; border-radius: 4px; border: none; background: #c678dd; color: white;">Next Row ‚Üë</button>
            <button onclick="pdeReset()" style="padding: 5px 15px; margin: 0 5px; cursor: pointer; border-radius: 4px; border: none; background: #e06c75; color: white;">Reset</button>
        </div>
        <p class="tiny-text center-text" style="margin-top: 5px; color: #888;">
            "Step Stencil" moves one cell in space | "Next Row" completes a time step
        </p>
    </section>

    <section>
        <h2>The Stencil</h2>
        <p class="small-text">Each new value depends on neighboring values:</p>
        <div class="three-column" style="margin-top: 20px; text-align: center;">
            <div>
                <p class="tiny-text"><strong>FTCS</strong></p>
                <p class="tiny-text" style="color: #888;">(Forward Time,<br>Central Space)</p>
                <div class="stencil-grid">
                    <div class="stencil-cell stencil-inactive"></div>
                    <div class="stencil-cell stencil-target">$u_i^{n+1}$</div>
                    <div class="stencil-cell stencil-inactive"></div>
                    <div class="stencil-cell stencil-active">$u_{i-1}^n$</div>
                    <div class="stencil-cell stencil-active">$u_i^n$</div>
                    <div class="stencil-cell stencil-active">$u_{i+1}^n$</div>
                </div>
                <p class="tiny-text" style="margin-top: 8px; font-size: 0.55em;">$u_i^{n+1} = u_i^n + r(\Delta u)$</p>
            </div>
            <div class="fragment">
                <p class="tiny-text"><strong>BTCS</strong></p>
                <p class="tiny-text" style="color: #888;">(Backward Time,<br>Central Space)</p>
                <div class="stencil-grid">
                    <div class="stencil-cell stencil-active">$u_{i-1}^{n+1}$</div>
                    <div class="stencil-cell stencil-active">$u_i^{n+1}$</div>
                    <div class="stencil-cell stencil-active">$u_{i+1}^{n+1}$</div>
                    <div class="stencil-cell stencil-inactive"></div>
                    <div class="stencil-cell stencil-target">$u_i^n$</div>
                    <div class="stencil-cell stencil-inactive"></div>
                </div>
                <p class="tiny-text" style="margin-top: 8px; font-size: 0.55em;">Solve: $Au^{n+1} = u^n$</p>
            </div>
            <div class="fragment">
                <p class="tiny-text"><strong>Crank-Nicolson</strong></p>
                <p class="tiny-text" style="color: #888;">(Average<br>FTCS + BTCS)</p>
                <div class="stencil-grid">
                    <div class="stencil-cell stencil-active">‚óè</div>
                    <div class="stencil-cell stencil-active">‚óè</div>
                    <div class="stencil-cell stencil-active">‚óè</div>
                    <div class="stencil-cell stencil-active">‚óè</div>
                    <div class="stencil-cell stencil-active">‚óè</div>
                    <div class="stencil-cell stencil-active">‚óè</div>
                </div>
                <p class="tiny-text" style="margin-top: 8px;">$O((\Delta t)^2, (\Delta x)^2)$ accuracy</p>
            </div>
        </div>
    </section>

    <section>
        <h2>Stability: The CFL Condition</h2>
        <div class="two-column">
            <div style="flex: 1.3;">
                <svg id="cfl-demo-viz" width="500" height="320" style="background: rgba(0,0,0,0.2); border-radius: 8px;"></svg>
                <div class="slider-container" style="margin-top: 10px;">
                    <label>r =</label>
                    <input type="range" id="cfl-r" min="0.1" max="0.8" step="0.05" value="0.4">
                    <span id="cfl-r-val">0.40</span>
                </div>
                <div style="text-align: center; margin-top: 5px;">
                    <button onclick="runCFLDemo()" style="padding: 5px 20px; cursor: pointer; border-radius: 4px; border: none; background: #61afef; color: white;">Run Simulation</button>
                </div>
            </div>
            <div style="flex: 1;">
                <div class="equation-box small-text">
                    <strong>CFL Condition:</strong><br><br>
                    $r = \frac{D \cdot \Delta t}{(\Delta x)^2} \leq \frac{1}{2}$
                </div>
                <div id="cfl-status" class="success-box small-text" style="margin-top: 15px;">
                    <strong>r = 0.40:</strong> Stable ‚úì<br>
                    Solution remains bounded
                </div>
                <p class="tiny-text" style="margin-top: 10px; color: #888;">
                    Try r > 0.5 to see instability!
                </p>
                <p class="tiny-text" style="margin-top: 15px;">
                    <a href="https://en.wikipedia.org/wiki/Courant%E2%80%93Friedrichs%E2%80%93Lewy_condition" target="_blank" style="color: #61afef;">
                        Courant-Friedrichs-Lewy condition ‚Üí
                    </a>
                </p>
            </div>
        </div>
        <div class="fragment warning-box small-text" style="margin-top: 15px;">
            <strong>Implicit schemes</strong> (BTCS, Crank-Nicolson) are unconditionally stable but require solving linear systems.
        </div>
    </section>
</section>

<!-- ============================================ -->
<!-- PHYSICS-INFORMED NUMERICAL SOLVERS -->
<!-- ============================================ -->
<section>
    <section>
        <h2 style="color: var(--accent-purple);">Physics-Informed Numerical Solvers</h2>
        <p class="small-text" style="margin-top: 30px;">How do we build numerical methods that respect physical laws?</p>
        <ul class="small-text" style="margin-top: 20px;">
            <li class="fragment">Better integrators (Runge-Kutta)</li>
            <li class="fragment">Conservation laws (Finite Volume)</li>
            <li class="fragment">Stability & incompressibility (Navier-Stokes)</li>
        </ul>
    </section>

    <section>
        <h2>Better Integrators: Runge-Kutta</h2>
        <p class="small-text">The workhorse of scientific computing</p>
        <div class="equation-box" style="font-size: 0.9em; padding: 15px;">
            <strong>RK4:</strong> &nbsp; $x_{n+1} = x_n + \frac{\Delta t}{6}(k_1 + 2k_2 + 2k_3 + k_4)$
        </div>
        <div class="two-column" style="margin-top: 15px;">
            <div class="highlight-box tiny-text" style="padding: 10px;">
                $k_1 = f(t_n, x_n)$<br>
                $k_2 = f(t_n + \frac{\Delta t}{2}, x_n + \frac{\Delta t}{2}k_1)$
            </div>
            <div class="highlight-box tiny-text" style="padding: 10px;">
                $k_3 = f(t_n + \frac{\Delta t}{2}, x_n + \frac{\Delta t}{2}k_2)$<br>
                $k_4 = f(t_n + \Delta t, x_n + \Delta t \cdot k_3)$
            </div>
        </div>
        <p class="fragment tiny-text center-text" style="margin-top: 15px; color: #888;">
            Sample the slope at 4 points, take a weighted average ‚Üí 4th-order accuracy!
        </p>
    </section>

    <section>
        <h2>Why RK4?</h2>
        <ul>
            <li class="fragment">Error: $O((\Delta t)^4)$ ‚Äî much better than Euler!</li>
            <li class="fragment">Evaluates $f$ at multiple points per step</li>
            <li class="fragment">Good balance of accuracy and efficiency</li>
            <li class="fragment">Used in most ODE solvers (MATLAB's <code>ode45</code>, SciPy's <code>solve_ivp</code>)</li>
        </ul>
        <div class="fragment highlight-box small-text" style="margin-top: 20px;">
            <strong>Adaptive methods:</strong> Automatically adjust $\Delta t$ based on estimated error
        </div>
    </section>

    <!-- FINITE VOLUME -->
    <section>
        <h2>Preserving Physics: Finite Volume Methods</h2>
    <p class="small-text">When equations have <strong>conservative form</strong>:</p>
    <div class="equation-box">
        $\frac{\partial \rho}{\partial t} + \frac{\partial F}{\partial x} = 0$
    </div>
    <p class="fragment small-text" style="margin-top: 15px;">Finite volume methods ensure <strong>conservation is preserved</strong> in the discretization.</p>
    <div class="fragment principle-box small-text" style="margin-top: 15px;">
        <strong>Key idea:</strong> What flows out of one cell flows into the next.<br>
        No mass/energy is created or destroyed numerically.
    </div>
    <p class="fragment small-text" style="margin-top: 15px;">
        Theme in Scientific ML: <strong>Encode physical knowledge into numerical schemes</strong>
    </p>
    </section>

    <section>
        <h2>Finite Volume: The Flux Picture</h2>
    <div class="two-column">
        <div style="flex: 1.2;">
            <div style="position: relative; width: 450px; height: 200px;">
                <svg width="450" height="200" style="background: rgba(0,0,0,0.2); border-radius: 8px;">
                    <!-- Cell boxes -->
                    <rect x="60" y="60" width="100" height="90" fill="rgba(97,175,239,0.2)" stroke="#61afef" stroke-width="2"/>
                    <rect x="160" y="60" width="100" height="90" fill="rgba(152,195,121,0.3)" stroke="#98c379" stroke-width="3"/>
                    <rect x="260" y="60" width="100" height="90" fill="rgba(97,175,239,0.2)" stroke="#61afef" stroke-width="2"/>
                    <!-- Flux arrows -->
                    <defs>
                        <marker id="arrowhead" markerWidth="10" markerHeight="7" refX="9" refY="3.5" orient="auto">
                            <polygon points="0 0, 10 3.5, 0 7" fill="#e5c07b"/>
                        </marker>
                    </defs>
                    <line x1="110" y1="35" x2="160" y2="35" stroke="#e5c07b" stroke-width="3" marker-end="url(#arrowhead)"/>
                    <line x1="210" y1="35" x2="260" y2="35" stroke="#e5c07b" stroke-width="3" marker-end="url(#arrowhead)"/>
                    <!-- Interface lines -->
                    <line x1="160" y1="55" x2="160" y2="155" stroke="#888" stroke-width="1" stroke-dasharray="5,5"/>
                    <line x1="260" y1="55" x2="260" y2="155" stroke="#888" stroke-width="1" stroke-dasharray="5,5"/>
                </svg>
                <!-- Labels positioned absolutely to align with boxes -->
                <div class="tiny-text" style="position: absolute; top: 105px; left: 110px; transform: translateX(-50%);">$\rho_{i-1}$</div>
                <div class="tiny-text" style="position: absolute; top: 105px; left: 210px; transform: translateX(-50%);">$\rho_i$</div>
                <div class="tiny-text" style="position: absolute; top: 105px; left: 310px; transform: translateX(-50%);">$\rho_{i+1}$</div>
                <div class="tiny-text" style="position: absolute; top: -25px; left: 135px; transform: translateX(-50%); color: #e5c07b;">$F_{i-\frac{1}{2}}$</div>
                <div class="tiny-text" style="position: absolute; top: -25px; left: 235px; transform: translateX(-50%); color: #e5c07b;">$F_{i+\frac{1}{2}}$</div>
            </div>
            <div class="equation-box tiny-text" style="margin-top: 10px; padding: 8px;">
                $\rho_i^{n+1} = \rho_i^n - \frac{\Delta t}{\Delta x}(F_{i+\frac{1}{2}} - F_{i-\frac{1}{2}})$
            </div>
        </div>
        <div style="flex: 1;">
            <div class="highlight-box tiny-text" style="padding: 12px;">
                <strong>Upwind Scheme:</strong><br>
                If $u > 0$ (flow right):<br>
                &nbsp;&nbsp;$F_{i+\frac{1}{2}} = u \cdot \rho_i$<br><br>
                If $u < 0$ (flow left):<br>
                &nbsp;&nbsp;$F_{i+\frac{1}{2}} = u \cdot \rho_{i+1}$
            </div>
            <div class="fragment success-box tiny-text" style="margin-top: 10px; padding: 10px;">
                <strong>Why upwind?</strong><br>
                Information travels <em>with</em> the flow.<br>
                Using "downwind" values is unstable!
            </div>
        </div>
    </div>
    <p class="fragment tiny-text center-text" style="color: #888; margin-top: 10px;">
        Conservation: What enters one cell exits the neighbor. No numerical mass loss.
    </p>
    </section>

    <!-- 2D FLUID SIMULATOR (sub-slides) -->
    <section>
        <h2>Interactive: 2D Fluid Dynamics</h2>
        <div class="equation-box tiny-text" style="margin-bottom: 8px; padding: 6px; font-size: 0.7em;">
            <strong>Navier-Stokes:</strong> $\begin{aligned} \frac{\partial \mathbf{u}}{\partial t} + (\mathbf{u} \cdot \nabla)\mathbf{u} &= -\frac{1}{\rho}\nabla p + \nu \nabla^2 \mathbf{u} \\ \nabla \cdot \mathbf{u} &= 0 \quad \text{(incompressible)} \end{aligned}$
        </div>
        <div class="two-column">
            <div style="flex: 1.6;">
                <canvas id="fluid-canvas" width="500" height="350" style="border-radius: 8px; cursor: crosshair;"></canvas>
            </div>
            <div style="flex: 0.7;">
                <div class="highlight-box tiny-text" style="padding: 8px; margin-bottom: 8px;">
                    <strong>Solver:</strong> Source ‚Üí Diffuse ‚Üí Project ‚Üí Advect ‚Üí Project
                </div>
                <div class="slider-container">
                    <label style="font-style: italic;">ŒΩ</label>
                    <input type="range" id="fluid-visc" min="0.00001" max="0.001" step="0.00001" value="0.0001">
                    <span id="fluid-visc-val">1e-4</span>
                </div>
                <div class="slider-container">
                    <label style="font-style: italic;">D</label>
                    <input type="range" id="fluid-diff" min="0.00001" max="0.001" step="0.00001" value="0.0001">
                    <span id="fluid-diff-val">1e-4</span>
                </div>
                <div class="slider-container">
                    <label>|u‚ÇÄ|</label>
                    <input type="range" id="fluid-flow" min="5" max="40" step="5" value="15">
                    <span id="fluid-flow-val">15</span>
                </div>
                <div class="tiny-text" style="margin-top: 8px; color: #888; font-size: 0.55em;">
                    $\nu$: viscosity | $D$: dye diffusion | $|u_0|$: inlet velocity
                </div>
            </div>
        </div>
        <p class="tiny-text center-text" style="margin-top: 5px; color: #888;">
            <span style="color: #e06c75;">Red = source</span> | Mouse = obstacle (blocks flow) | Real Navier-Stokes in browser!
        </p>
    </section>

    <section>
        <h2>The Discretized Equations</h2>
        <p class="small-text">Each step solves part of Navier-Stokes numerically:</p>
        <div class="two-column small-text" style="margin-top: 15px;">
            <div class="fragment">
                <div class="highlight-box" style="padding: 12px; text-align: center;">
                    <strong>1. Diffusion</strong> (implicit, stable)<br><br>
                    $(I - \nu \Delta t \nabla^2) u^{n+1} = u^n$<br><br>
                    <span class="tiny-text" style="color: #aaa;">Gauss-Seidel iteration:</span><br>
                    $u_{i,j}^{k+1} = \frac{u_{i,j}^n + a \sum_{\text{neighbors}}}{1 + 4a}$
                </div>
            </div>
            <div class="fragment">
                <div class="highlight-box" style="padding: 12px; text-align: center;">
                    <strong>2. Advection</strong> (semi-Lagrangian)<br><br>
                    $q^{n+1}(\mathbf{x}) = q^n(\mathbf{x} - \mathbf{u}\Delta t)$<br><br>
                    <span class="tiny-text" style="color: #aaa;">"Where did this particle come from?"</span><br>
                    Trace backward, interpolate
                </div>
            </div>
        </div>
        <div class="fragment success-box tiny-text" style="margin-top: 15px; text-align: center;">
            <strong>Key insight:</strong> Implicit diffusion + semi-Lagrangian advection = unconditionally stable!
        </div>
        <p class="fragment tiny-text" style="margin-top: 10px;">
            Reference: <a href="https://www.dgp.toronto.edu/public_user/stam/reality/Research/pdf/ns.pdf" style="color: #61afef;">Jos Stam, "Stable Fluids" (SIGGRAPH 1999)</a>
        </p>
    </section>

    <section>
        <h2>Enforcing Incompressibility</h2>
        <p class="small-text">After diffusion and advection, velocity may not satisfy $\nabla \cdot \mathbf{u} = 0$</p>
        <div class="equation-box small-text" style="margin-top: 15px;">
            <strong>Helmholtz decomposition:</strong> $\mathbf{u} = \mathbf{u}_{\text{div-free}} + \nabla p$
        </div>
        <div class="fragment" style="margin-top: 15px;">
            <p class="small-text">Solve Poisson equation for pressure:</p>
            <div class="highlight-box small-text">
                $\nabla^2 p = \nabla \cdot \mathbf{u}$ &nbsp;&nbsp;‚Üí&nbsp;&nbsp; $\mathbf{u}_{\text{div-free}} = \mathbf{u} - \nabla p$
            </div>
        </div>
        <div class="fragment principle-box small-text" style="margin-top: 15px;">
            <strong>Algorithm:</strong> Add sources ‚Üí Diffuse ‚Üí Project ‚Üí Advect ‚Üí Project
        </div>
    </section>
</section>

<!-- ============================================ -->
<!-- LORENZ SYSTEM -->
<!-- ============================================ -->
<section>
    <section>
        <h2>Rayleigh-B√©nard Convection</h2>
        <div class="two-column">
            <div style="flex: 1.2;">
                <svg width="450" height="280" style="background: rgba(0,0,0,0.2); border-radius: 8px;">
                    <!-- Container -->
                    <rect x="50" y="40" width="350" height="180" fill="none" stroke="#666" stroke-width="2"/>
                    <!-- Hot plate (bottom) -->
                    <rect x="50" y="220" width="350" height="25" fill="#e06c75"/>
                    <text x="225" y="238" fill="white" text-anchor="middle" font-size="12">HOT</text>
                    <!-- Cold plate (top) -->
                    <rect x="50" y="15" width="350" height="25" fill="#61afef"/>
                    <text x="225" y="32" fill="white" text-anchor="middle" font-size="12">COLD</text>
                    <!-- Convection cells - arrows showing circulation -->
                    <defs>
                        <marker id="conv-arrow" markerWidth="6" markerHeight="6" refX="5" refY="3" orient="auto">
                            <polygon points="0 0, 6 3, 0 6" fill="#e5c07b"/>
                        </marker>
                    </defs>
                    <!-- Left cell -->
                    <path d="M 100 180 Q 100 130 150 130 Q 200 130 200 80" stroke="#e5c07b" stroke-width="2" fill="none" marker-end="url(#conv-arrow)"/>
                    <path d="M 200 80 Q 200 130 150 130 Q 100 130 100 180" stroke="#56b6c2" stroke-width="2" fill="none" stroke-dasharray="5,5"/>
                    <!-- Right cell -->
                    <path d="M 250 80 Q 250 130 300 130 Q 350 130 350 180" stroke="#56b6c2" stroke-width="2" fill="none" stroke-dasharray="5,5"/>
                    <path d="M 350 180 Q 350 130 300 130 Q 250 130 250 80" stroke="#e5c07b" stroke-width="2" fill="none" marker-end="url(#conv-arrow)"/>
                    <!-- Labels -->
                    <text x="150" y="100" fill="#e5c07b" font-size="10">warm ‚Üë</text>
                    <text x="300" y="160" fill="#56b6c2" font-size="10">cool ‚Üì</text>
                </svg>
            </div>
            <div style="flex: 1;">
                <p class="small-text">
                    <strong>The physics:</strong> Fluid heated from below, cooled from above.
                </p>
                <ul class="tiny-text" style="margin-top: 10px;">
                    <li>Warm fluid rises (less dense)</li>
                    <li>Cool fluid sinks (more dense)</li>
                    <li>Creates convection cells</li>
                    <li>Basic mechanism of weather!</li>
                </ul>
                <div class="fragment principle-box tiny-text" style="margin-top: 15px;">
                    Many equations describe this: velocity, temperature, pressure fields in 3D...
                </div>
            </div>
        </div>
    </section>

    <section>
        <h2>From 7 Equations to 3: The Saltzman-Lorenz Story</h2>
        <div class="two-column">
            <div>
                <p class="small-text"><strong>Barry Saltzman</strong> (Yale, 1961) developed a 7-equation model for convection.</p>
                <p class="fragment small-text" style="margin-top: 15px;">He showed it to <strong>Edward Lorenz</strong> at MIT ‚Äî one solution "refused to settle down."</p>
                <p class="fragment small-text" style="margin-top: 15px;">Lorenz noticed: <em>4 variables quickly became tiny. Only 3 were "keeping each other going."</em></p>
            </div>
            <div class="fragment">
                <div class="highlight-box tiny-text" style="padding: 12px;">
                    <strong>Lorenz's insight:</strong><br><br>
                    "Barry gave me the go-ahead signal, and back at MIT the next morning I put the three equations on the computer..."<br><br>
                    "...and sure enough, there was the same lack of periodicity."
                </div>
                <p class="tiny-text" style="margin-top: 10px; color: #888;">
                    <a href="https://journals.ametsoc.org/view/journals/bams/105/7/BAMS-D-23-0157.1.xml" style="color: #61afef;">Saltzman-Lorenz Exchange, 1961 ‚Üí</a>
                </p>
            </div>
        </div>
    </section>

    <section>
        <h2>The Lorenz Equations</h2>
        <p class="small-text">Saltzman's 7 equations ‚Üí Lorenz's 3 equations:</p>
        <div class="equation-box" style="margin-top: 15px; font-size: 0.85em;">
            $\dot{x} = \sigma(y - x)$ &emsp;&emsp;
            $\dot{y} = x(\rho - z) - y$ &emsp;&emsp;
            $\dot{z} = xy - \beta z$
        </div>
        <div class="fragment two-column tiny-text" style="margin-top: 20px;">
            <div>
                <strong>Variables:</strong><br>
                $x$ = intensity of convection<br>
                $y$ = horizontal temperature diff<br>
                $z$ = vertical temperature deviation
            </div>
            <div>
                <strong>Parameters (chaotic regime):</strong><br>
                $\sigma = 10$, $\rho = 28$, $\beta = 8/3$
            </div>
        </div>
        <p class="fragment tiny-text" style="margin-top: 15px; color: #888;">
            Just 3 coupled ODEs, yet the dynamics are incredibly complex
        </p>
    </section>

    <section>
        <h2>The Lorenz Attractor</h2>
        <div class="two-column">
            <div style="flex: 1.5;">
                <svg id="lorenz-viz" width="500" height="380" style="background: rgba(0,0,0,0.2); border-radius: 8px;"></svg>
            </div>
            <div style="flex: 0.8;">
                <div id="lorenz-coords" class="highlight-box tiny-text" style="font-family: monospace; padding: 10px;">
                    x = 1.00<br>
                    y = 1.00<br>
                    z = 1.00
                </div>
                <div style="margin-top: 15px;">
                    <div class="slider-container">
                        <label>Speed:</label>
                        <input type="range" id="lorenz-speed" min="1" max="10" step="1" value="3">
                        <span id="lorenz-speed-val">3</span>
                    </div>
                    <div class="slider-container">
                        <label>Trail:</label>
                        <input type="range" id="lorenz-trail" min="500" max="3000" step="250" value="1500">
                        <span id="lorenz-trail-val">1500</span>
                    </div>
                </div>
                <button onclick="resetLorenz()" style="margin-top: 10px; padding: 5px 15px; cursor: pointer; border-radius: 4px; border: none; background: #61afef; color: white; width: 100%;">Reset</button>
            </div>
        </div>
        <p class="tiny-text center-text" style="margin-top: 5px; color: #888;">
            The trajectory never repeats but stays on this strange "butterfly" shape
        </p>
    </section>

    <section>
        <h2>The Accident</h2>
        <p class="small-text">Lorenz wanted to extend a simulation. Instead of starting over, he typed in the values from a printout:</p>
        <div class="two-column" style="margin-top: 20px;">
            <div class="highlight-box small-text" style="text-align: center;">
                <strong>Printout showed:</strong><br><br>
                <span style="font-family: monospace; font-size: 1.3em;">0.506</span>
            </div>
            <div class="highlight-box small-text" style="text-align: center;">
                <strong>Computer stored:</strong><br><br>
                <span style="font-family: monospace; font-size: 1.3em;">0.506127</span>
            </div>
        </div>
        <p class="fragment small-text" style="margin-top: 20px; text-align: center;">
            A difference of about <strong>0.0001</strong> ‚Äî surely that can't matter?
        </p>
        <p class="fragment small-text" style="margin-top: 15px; text-align: center;">
            He goes for a coffee, comes back, and...
        </p>
    </section>

    <section>
        <h2>The Weather is Completely Different!</h2>
        <div style="display: flex; justify-content: center;">
            <svg id="lorenz-diverge-viz" width="800" height="300" style="background: rgba(0,0,0,0.2); border-radius: 8px;"></svg>
        </div>
        <p class="small-text center-text" style="margin-top: 15px;">
            The two simulations start nearly identical, then <strong>completely diverge</strong>.
        </p>
        <div class="fragment warning-box small-text" style="margin-top: 15px;">
            <strong>Wait... what's happening here?</strong><br>
            The equations are <em>deterministic</em>. Same input ‚Üí same output, right?
        </div>
    </section>

    <section>
        <h2>Sensitivity to Initial Conditions</h2>
        <div style="display: flex; justify-content: center;">
            <svg id="lorenz-sensitivity-viz" width="800" height="320" style="background: rgba(0,0,0,0.2); border-radius: 8px;"></svg>
        </div>
        <div class="slider-container" style="justify-content: center; margin-top: 10px;">
            <label style="font-size: 0.9em;">Perturbation <span style="font-style: italic;">&#949;</span> =</label>
            <input type="range" id="lorenz-perturb" min="-6" max="-2" step="0.5" value="-4">
            <span id="lorenz-perturb-val" style="font-size: 1em; min-width: 60px;">10<sup>-4</sup></span>
        </div>
        <p class="small-text center-text" style="margin-top: 10px;">
            <span style="color: #61afef;">&#9632; Original</span> vs <span style="color: #e06c75;">&#9632; Perturbed by &#949;</span>
        </p>
        <p class="fragment tiny-text center-text" style="color: #888;">
            No matter how small &#949; is, the trajectories <em>eventually</em> diverge completely.
        </p>
    </section>

    <section>
        <h2>The Butterfly Effect</h2>
        <blockquote style="font-size: 0.85em;">
            "Does the flap of a butterfly's wings in Brazil set off a tornado in Texas?"
            <footer>‚Äî Edward Lorenz, 1972</footer>
        </blockquote>
        <div class="fragment" style="margin-top: 20px;">
            <p class="small-text"><strong>Lorenz's discovery:</strong></p>
            <ul class="small-text">
                <li>Deterministic ‚â† Predictable</li>
                <li>Tiny errors grow <em>exponentially</em> fast</li>
                <li>Long-term weather prediction has a <strong>fundamental limit</strong> (~2 weeks)</li>
            </ul>
        </div>
        <div class="fragment principle-box small-text" style="margin-top: 15px;">
            This is <strong>chaos</strong>: sensitivity to initial conditions in deterministic systems.
        </div>
    </section>
</section>

<!-- ============================================ -->
<!-- SUMMARY -->
<!-- ============================================ -->
<section>
    <h2>Summary</h2>
    <ol class="small-text">
        <li class="fragment"><strong>Computing = recursive rule application</strong> (from Peano to PDEs)</li>
        <li class="fragment"><strong>Discretization:</strong> Turn differential equations into algebraic ones</li>
        <li class="fragment"><strong>Error analysis:</strong> Taylor expansion tells us accuracy ($O(\Delta t)$, $O(\Delta t^2)$, ...)</li>
        <li class="fragment"><strong>Stability:</strong> Not all $\Delta t$ work; implicit vs explicit schemes</li>
        <li class="fragment"><strong>Runge-Kutta:</strong> The workhorse of ODE solving</li>
        <li class="fragment"><strong>Finite volume:</strong> Preserve physics (conservation) in numerics</li>
        <li class="fragment"><strong>Chaos:</strong> Sensitivity to initial conditions limits predictability</li>
    </ol>
</section>

<!-- ============================================ -->
<!-- LOOKING AHEAD -->
<!-- ============================================ -->
<section>
    <h2>Looking Ahead</h2>
    <p>If systems are chaotic and sensitive...</p>
    <p class="fragment"><strong>How do we account for uncertainty?</strong></p>
    <div class="fragment highlight-box" style="margin-top: 20px;">
        <strong>Next lecture:</strong> Probabilistic Modeling and Uncertainty Quantification
        <ul class="small-text" style="margin-top: 10px;">
            <li>Probability distributions over predictions</li>
            <li>Bayesian inference</li>
            <li>Monte Carlo methods</li>
            <li>Connecting uncertainty in ML and scientific computing</li>
        </ul>
    </div>
</section>

<section class="center-text">
    <h2>Questions?</h2>
    <p style="margin-top: 40px; color: #888;">See you next time!</p>
</section>

</div>
</div>

<script src="https://cdn.jsdelivr.net/npm/reveal.js@4.5.0/dist/reveal.js"></script>
<script src="https://cdn.jsdelivr.net/npm/reveal.js@4.5.0/plugin/math/math.js"></script>
<script src="https://cdn.jsdelivr.net/npm/reveal.js@4.5.0/plugin/highlight/highlight.js"></script>
<script>
    Reveal.initialize({
        hash: true,
        slideNumber: 'c/t',
        transition: 'slide',
        transitionSpeed: 'default',
        backgroundTransition: 'fade',
        plugins: [ RevealMath.KaTeX, RevealHighlight ],
        width: 1100,
        height: 650,
        margin: 0.15,
        minScale: 0.2,
        maxScale: 2.0
    });

    // ==========================================
    // PREDATOR-PREY: HUDSON BAY DATA & FITTING
    // ==========================================
    // Historical Hudson Bay Company data (1900-1920, approximate values in thousands)
    // Based on Elton & Nicholson (1942) and MacLulich (1937)
    const hudsonBayData = {
        years: [1900, 1901, 1902, 1903, 1904, 1905, 1906, 1907, 1908, 1909,
                1910, 1911, 1912, 1913, 1914, 1915, 1916, 1917, 1918, 1919, 1920],
        hare: [30, 47, 70, 78, 36, 20, 9, 7, 10, 28,
               55, 82, 73, 40, 18, 10, 8, 13, 28, 55, 80],
        lynx: [4, 7, 12, 25, 44, 36, 15, 5, 3, 4,
               6, 12, 22, 38, 50, 32, 12, 5, 4, 5, 8]
    };

    function drawHudsonData() {
        const svg = document.getElementById('hudson-data-viz');
        if (!svg) return;

        const width = 420, height = 220;
        const margin = { top: 15, right: 20, bottom: 35, left: 45 };
        const plotW = width - margin.left - margin.right;
        const plotH = height - margin.top - margin.bottom;

        svg.innerHTML = '';

        const g = document.createElementNS('http://www.w3.org/2000/svg', 'g');
        g.setAttribute('transform', `translate(${margin.left}, ${margin.top})`);
        svg.appendChild(g);

        // Axes
        const xAxis = document.createElementNS('http://www.w3.org/2000/svg', 'line');
        xAxis.setAttribute('x1', 0); xAxis.setAttribute('y1', plotH);
        xAxis.setAttribute('x2', plotW); xAxis.setAttribute('y2', plotH);
        xAxis.setAttribute('stroke', '#666'); xAxis.setAttribute('stroke-width', 1.5);
        g.appendChild(xAxis);

        const yAxis = document.createElementNS('http://www.w3.org/2000/svg', 'line');
        yAxis.setAttribute('x1', 0); yAxis.setAttribute('y1', 0);
        yAxis.setAttribute('x2', 0); yAxis.setAttribute('y2', plotH);
        yAxis.setAttribute('stroke', '#666'); yAxis.setAttribute('stroke-width', 1.5);
        g.appendChild(yAxis);

        // Labels
        const xLabel = document.createElementNS('http://www.w3.org/2000/svg', 'text');
        xLabel.setAttribute('x', plotW / 2); xLabel.setAttribute('y', plotH + 30);
        xLabel.setAttribute('fill', '#7ee8f3'); xLabel.setAttribute('text-anchor', 'middle');
        xLabel.setAttribute('font-size', '16px');
        xLabel.textContent = 'Year';
        g.appendChild(xLabel);

        const yLabel = document.createElementNS('http://www.w3.org/2000/svg', 'text');
        yLabel.setAttribute('x', -plotH / 2); yLabel.setAttribute('y', -32);
        yLabel.setAttribute('fill', '#f5d990'); yLabel.setAttribute('text-anchor', 'middle');
        yLabel.setAttribute('transform', 'rotate(-90)');
        yLabel.setAttribute('font-size', '16px');
        yLabel.textContent = 'Population (thousands)';
        g.appendChild(yLabel);

        const years = hudsonBayData.years;
        const tMin = years[0], tMax = years[years.length - 1];
        const maxPop = Math.max(...hudsonBayData.hare, ...hudsonBayData.lynx) * 1.1;

        // Draw hare data
        let harePath = '';
        hudsonBayData.hare.forEach((h, i) => {
            const x = ((years[i] - tMin) / (tMax - tMin)) * plotW;
            const y = plotH - (h / maxPop) * plotH;
            harePath += (i === 0 ? 'M' : 'L') + `${x},${y}`;
        });
        const hareCurve = document.createElementNS('http://www.w3.org/2000/svg', 'path');
        hareCurve.setAttribute('d', harePath);
        hareCurve.setAttribute('stroke', '#61afef');
        hareCurve.setAttribute('stroke-width', 2);
        hareCurve.setAttribute('fill', 'none');
        g.appendChild(hareCurve);

        // Draw lynx data
        let lynxPath = '';
        hudsonBayData.lynx.forEach((l, i) => {
            const x = ((years[i] - tMin) / (tMax - tMin)) * plotW;
            const y = plotH - (l / maxPop) * plotH;
            lynxPath += (i === 0 ? 'M' : 'L') + `${x},${y}`;
        });
        const lynxCurve = document.createElementNS('http://www.w3.org/2000/svg', 'path');
        lynxCurve.setAttribute('d', lynxPath);
        lynxCurve.setAttribute('stroke', '#e06c75');
        lynxCurve.setAttribute('stroke-width', 2);
        lynxCurve.setAttribute('fill', 'none');
        g.appendChild(lynxCurve);

        // Draw data points
        hudsonBayData.hare.forEach((h, i) => {
            const x = ((years[i] - tMin) / (tMax - tMin)) * plotW;
            const y = plotH - (h / maxPop) * plotH;
            const dot = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
            dot.setAttribute('cx', x); dot.setAttribute('cy', y);
            dot.setAttribute('r', 3); dot.setAttribute('fill', '#61afef');
            g.appendChild(dot);
        });

        hudsonBayData.lynx.forEach((l, i) => {
            const x = ((years[i] - tMin) / (tMax - tMin)) * plotW;
            const y = plotH - (l / maxPop) * plotH;
            const dot = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
            dot.setAttribute('cx', x); dot.setAttribute('cy', y);
            dot.setAttribute('r', 3); dot.setAttribute('fill', '#e06c75');
            g.appendChild(dot);
        });

        // Year tick marks
        [1900, 1905, 1910, 1915, 1920].forEach(yr => {
            const x = ((yr - tMin) / (tMax - tMin)) * plotW;
            const tick = document.createElementNS('http://www.w3.org/2000/svg', 'text');
            tick.setAttribute('x', x); tick.setAttribute('y', plotH + 15);
            tick.setAttribute('fill', '#888'); tick.setAttribute('text-anchor', 'middle');
            tick.setAttribute('font-size', '9px');
            tick.textContent = yr.toString();
            g.appendChild(tick);
        });
    }

    function initPredPreyFit() {
        drawPredPreyFit();
    }

    function drawPredPreyFit() {
        const svg = document.getElementById('predprey-fit-viz');
        if (!svg) return;

        const alpha = parseFloat(document.getElementById('pp-alpha')?.value || 0.55);
        const beta = parseFloat(document.getElementById('pp-beta')?.value || 0.028);
        const delta = parseFloat(document.getElementById('pp-delta')?.value || 0.018);
        const gamma = parseFloat(document.getElementById('pp-gamma')?.value || 0.84);

        // Update displays
        if (document.getElementById('pp-alpha-val')) document.getElementById('pp-alpha-val').textContent = alpha.toFixed(2);
        if (document.getElementById('pp-beta-val')) document.getElementById('pp-beta-val').textContent = beta.toFixed(3);
        if (document.getElementById('pp-delta-val')) document.getElementById('pp-delta-val').textContent = delta.toFixed(3);
        if (document.getElementById('pp-gamma-val')) document.getElementById('pp-gamma-val').textContent = gamma.toFixed(2);

        const width = 550, height = 320;
        const margin = { top: 20, right: 20, bottom: 40, left: 50 };
        const plotW = width - margin.left - margin.right;
        const plotH = height - margin.top - margin.bottom;

        svg.innerHTML = '';

        const g = document.createElementNS('http://www.w3.org/2000/svg', 'g');
        g.setAttribute('transform', `translate(${margin.left}, ${margin.top})`);
        svg.appendChild(g);

        // Axes
        const xAxis = document.createElementNS('http://www.w3.org/2000/svg', 'line');
        xAxis.setAttribute('x1', 0); xAxis.setAttribute('y1', plotH);
        xAxis.setAttribute('x2', plotW); xAxis.setAttribute('y2', plotH);
        xAxis.setAttribute('stroke', '#666'); xAxis.setAttribute('stroke-width', 1.5);
        g.appendChild(xAxis);

        const yAxis = document.createElementNS('http://www.w3.org/2000/svg', 'line');
        yAxis.setAttribute('x1', 0); yAxis.setAttribute('y1', 0);
        yAxis.setAttribute('x2', 0); yAxis.setAttribute('y2', plotH);
        yAxis.setAttribute('stroke', '#666'); yAxis.setAttribute('stroke-width', 1.5);
        g.appendChild(yAxis);

        // Labels
        const xLabel = document.createElementNS('http://www.w3.org/2000/svg', 'text');
        xLabel.setAttribute('x', plotW / 2); xLabel.setAttribute('y', plotH + 30);
        xLabel.setAttribute('fill', '#7ee8f3'); xLabel.setAttribute('text-anchor', 'middle');
        xLabel.setAttribute('font-size', '16px');
        xLabel.textContent = 'Year';
        g.appendChild(xLabel);

        const yLabel = document.createElementNS('http://www.w3.org/2000/svg', 'text');
        yLabel.setAttribute('x', -plotH / 2); yLabel.setAttribute('y', -35);
        yLabel.setAttribute('fill', '#f5d990'); yLabel.setAttribute('text-anchor', 'middle');
        yLabel.setAttribute('transform', 'rotate(-90)');
        yLabel.setAttribute('font-size', '16px');
        yLabel.textContent = 'Population (thousands)';
        g.appendChild(yLabel);

        const years = hudsonBayData.years;
        const tMin = years[0], tMax = years[years.length - 1];
        const maxPop = 100;

        // Simulate model using RK4
        const dt = 0.05;
        const simYears = 21;
        const stepsPerYear = Math.round(1 / dt);

        let x = hudsonBayData.hare[0];  // Initial hare population
        let y = hudsonBayData.lynx[0];  // Initial lynx population
        const simHare = [x];
        const simLynx = [y];
        const simTime = [0];

        for (let year = 0; year < simYears; year++) {
            for (let step = 0; step < stepsPerYear; step++) {
                // RK4 integration
                const f = (h, l) => [
                    alpha * h - beta * h * l,
                    delta * h * l - gamma * l
                ];
                const k1 = f(x, y);
                const k2 = f(x + dt/2 * k1[0], y + dt/2 * k1[1]);
                const k3 = f(x + dt/2 * k2[0], y + dt/2 * k2[1]);
                const k4 = f(x + dt * k3[0], y + dt * k3[1]);

                x += dt/6 * (k1[0] + 2*k2[0] + 2*k3[0] + k4[0]);
                y += dt/6 * (k1[1] + 2*k2[1] + 2*k3[1] + k4[1]);

                x = Math.max(0.1, x);
                y = Math.max(0.1, y);
            }
            simHare.push(x);
            simLynx.push(y);
            simTime.push(year + 1);
        }

        // Draw simulated hare line
        let simHarePath = '';
        simHare.forEach((h, i) => {
            const px = (simTime[i] / (tMax - tMin)) * plotW;
            const py = plotH - (Math.min(h, maxPop) / maxPop) * plotH;
            simHarePath += (i === 0 ? 'M' : 'L') + `${px},${py}`;
        });
        const simHareCurve = document.createElementNS('http://www.w3.org/2000/svg', 'path');
        simHareCurve.setAttribute('d', simHarePath);
        simHareCurve.setAttribute('stroke', '#61afef');
        simHareCurve.setAttribute('stroke-width', 2);
        simHareCurve.setAttribute('fill', 'none');
        g.appendChild(simHareCurve);

        // Draw simulated lynx line
        let simLynxPath = '';
        simLynx.forEach((l, i) => {
            const px = (simTime[i] / (tMax - tMin)) * plotW;
            const py = plotH - (Math.min(l, maxPop) / maxPop) * plotH;
            simLynxPath += (i === 0 ? 'M' : 'L') + `${px},${py}`;
        });
        const simLynxCurve = document.createElementNS('http://www.w3.org/2000/svg', 'path');
        simLynxCurve.setAttribute('d', simLynxPath);
        simLynxCurve.setAttribute('stroke', '#e06c75');
        simLynxCurve.setAttribute('stroke-width', 2);
        simLynxCurve.setAttribute('fill', 'none');
        g.appendChild(simLynxCurve);

        // Draw real data points (hare)
        hudsonBayData.hare.forEach((h, i) => {
            const px = ((years[i] - tMin) / (tMax - tMin)) * plotW;
            const py = plotH - (h / maxPop) * plotH;
            const dot = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
            dot.setAttribute('cx', px); dot.setAttribute('cy', py);
            dot.setAttribute('r', 5); dot.setAttribute('fill', '#61afef');
            dot.setAttribute('stroke', '#fff'); dot.setAttribute('stroke-width', 1);
            g.appendChild(dot);
        });

        // Draw real data points (lynx)
        hudsonBayData.lynx.forEach((l, i) => {
            const px = ((years[i] - tMin) / (tMax - tMin)) * plotW;
            const py = plotH - (l / maxPop) * plotH;
            const dot = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
            dot.setAttribute('cx', px); dot.setAttribute('cy', py);
            dot.setAttribute('r', 5); dot.setAttribute('fill', '#e06c75');
            dot.setAttribute('stroke', '#fff'); dot.setAttribute('stroke-width', 1);
            g.appendChild(dot);
        });

        // Year tick marks
        [1900, 1905, 1910, 1915, 1920].forEach(yr => {
            const x = ((yr - tMin) / (tMax - tMin)) * plotW;
            const tick = document.createElementNS('http://www.w3.org/2000/svg', 'text');
            tick.setAttribute('x', x); tick.setAttribute('y', plotH + 15);
            tick.setAttribute('fill', '#888'); tick.setAttribute('text-anchor', 'middle');
            tick.setAttribute('font-size', '10px');
            tick.textContent = yr.toString();
            g.appendChild(tick);
        });

        // Y-axis ticks
        [0, 25, 50, 75, 100].forEach(val => {
            const py = plotH - (val / maxPop) * plotH;
            const tick = document.createElementNS('http://www.w3.org/2000/svg', 'text');
            tick.setAttribute('x', -8); tick.setAttribute('y', py + 3);
            tick.setAttribute('fill', '#888'); tick.setAttribute('text-anchor', 'end');
            tick.setAttribute('font-size', '9px');
            tick.textContent = val.toString();
            g.appendChild(tick);
        });
    }

    function resetPredPreyFit() {
        document.getElementById('pp-alpha').value = 0.55;
        document.getElementById('pp-beta').value = 0.028;
        document.getElementById('pp-delta').value = 0.018;
        document.getElementById('pp-gamma').value = 0.84;
        drawPredPreyFit();
    }

    // ==========================================
    // GAME OF LIFE SIMULATION
    // ==========================================
    let lifeCanvas, lifeCtx;
    let lifeGrid = [];
    let lifeRows = 55, lifeCols = 75;
    let lifeGeneration = 0;
    let lifeAnimId = null;
    let lifePlaying = false;

    function initLife() {
        lifeCanvas = document.getElementById('life-canvas');
        if (!lifeCanvas) return;
        lifeCtx = lifeCanvas.getContext('2d');

        // Initialize grid
        lifeGrid = Array(lifeRows).fill(null).map(() => Array(lifeCols).fill(0));
        lifeGeneration = 0;
        lifePlaying = false;
        document.getElementById('life-gen').textContent = '0';
        document.getElementById('life-play').textContent = '‚ñ∂ Play';

        // Load default pattern
        loadLifePattern('glider');
        drawLife();

        // Button handlers
        document.getElementById('life-step').onclick = () => {
            stepLife();
            drawLife();
        };

        document.getElementById('life-play').onclick = () => {
            lifePlaying = !lifePlaying;
            document.getElementById('life-play').textContent = lifePlaying ? '‚è∏ Pause' : '‚ñ∂ Play';
            if (lifePlaying) animateLife();
        };

        document.getElementById('life-reset').onclick = () => {
            lifePlaying = false;
            if (lifeAnimId) cancelAnimationFrame(lifeAnimId);
            document.getElementById('life-play').textContent = '‚ñ∂ Play';
            lifeGeneration = 0;
            document.getElementById('life-gen').textContent = '0';
            loadLifePattern(document.getElementById('life-pattern').value);
            drawLife();
        };

        document.getElementById('life-pattern').onchange = (e) => {
            lifePlaying = false;
            if (lifeAnimId) cancelAnimationFrame(lifeAnimId);
            document.getElementById('life-play').textContent = '‚ñ∂ Play';
            lifeGeneration = 0;
            document.getElementById('life-gen').textContent = '0';
            loadLifePattern(e.target.value);
            drawLife();
        };

        // Click to toggle cells (account for Reveal.js scaling)
        lifeCanvas.onclick = (e) => {
            const rect = lifeCanvas.getBoundingClientRect();
            // Use rendered size to calculate position, not internal canvas size
            const col = Math.floor((e.clientX - rect.left) / rect.width * lifeCols);
            const row = Math.floor((e.clientY - rect.top) / rect.height * lifeRows);
            if (row >= 0 && row < lifeRows && col >= 0 && col < lifeCols) {
                lifeGrid[row][col] = 1 - lifeGrid[row][col];
                drawLife();
            }
        };
    }

    function loadLifePattern(name) {
        lifeGrid = Array(lifeRows).fill(null).map(() => Array(lifeCols).fill(0));
        const midR = Math.floor(lifeRows / 2);
        const midC = Math.floor(lifeCols / 2);

        if (name === 'glider') {
            // Glider at center
            const pattern = [[0,1],[1,2],[2,0],[2,1],[2,2]];
            pattern.forEach(([r,c]) => lifeGrid[midR+r][midC+c] = 1);
        } else if (name === 'blinker') {
            // Blinker (oscillator)
            lifeGrid[midR][midC-1] = 1;
            lifeGrid[midR][midC] = 1;
            lifeGrid[midR][midC+1] = 1;
        } else if (name === 'glider-gun') {
            // Gosper Glider Gun (simplified position)
            const gun = [
                [5,1],[5,2],[6,1],[6,2],
                [5,11],[6,11],[7,11],[4,12],[8,12],[3,13],[9,13],[3,14],[9,14],[6,15],
                [4,16],[8,16],[5,17],[6,17],[7,17],[6,18],
                [3,21],[4,21],[5,21],[3,22],[4,22],[5,22],[2,23],[6,23],[1,25],[2,25],[6,25],[7,25],
                [3,35],[4,35],[3,36],[4,36]
            ];
            gun.forEach(([r,c]) => {
                if (r < lifeRows && c < lifeCols) lifeGrid[r][c] = 1;
            });
        } else if (name === 'random') {
            for (let r = 0; r < lifeRows; r++) {
                for (let c = 0; c < lifeCols; c++) {
                    lifeGrid[r][c] = Math.random() < 0.3 ? 1 : 0;
                }
            }
        }
    }

    function stepLife() {
        const newGrid = Array(lifeRows).fill(null).map(() => Array(lifeCols).fill(0));

        for (let r = 0; r < lifeRows; r++) {
            for (let c = 0; c < lifeCols; c++) {
                let neighbors = 0;
                for (let dr = -1; dr <= 1; dr++) {
                    for (let dc = -1; dc <= 1; dc++) {
                        if (dr === 0 && dc === 0) continue;
                        const nr = (r + dr + lifeRows) % lifeRows;
                        const nc = (c + dc + lifeCols) % lifeCols;
                        neighbors += lifeGrid[nr][nc];
                    }
                }

                if (lifeGrid[r][c] === 1) {
                    // Alive: survives with 2-3 neighbors
                    newGrid[r][c] = (neighbors === 2 || neighbors === 3) ? 1 : 0;
                } else {
                    // Dead: born with exactly 3 neighbors
                    newGrid[r][c] = (neighbors === 3) ? 1 : 0;
                }
            }
        }

        lifeGrid = newGrid;
        lifeGeneration++;
        document.getElementById('life-gen').textContent = lifeGeneration;
    }

    function drawLife() {
        if (!lifeCtx) return;
        const w = lifeCanvas.width;
        const h = lifeCanvas.height;
        const cellW = w / lifeCols;
        const cellH = h / lifeRows;

        lifeCtx.fillStyle = '#1a1a2e';
        lifeCtx.fillRect(0, 0, w, h);

        // Draw grid lines (subtle)
        lifeCtx.strokeStyle = 'rgba(255,255,255,0.05)';
        lifeCtx.lineWidth = 0.5;
        for (let r = 0; r <= lifeRows; r++) {
            lifeCtx.beginPath();
            lifeCtx.moveTo(0, r * cellH);
            lifeCtx.lineTo(w, r * cellH);
            lifeCtx.stroke();
        }
        for (let c = 0; c <= lifeCols; c++) {
            lifeCtx.beginPath();
            lifeCtx.moveTo(c * cellW, 0);
            lifeCtx.lineTo(c * cellW, h);
            lifeCtx.stroke();
        }

        // Draw cells
        for (let r = 0; r < lifeRows; r++) {
            for (let c = 0; c < lifeCols; c++) {
                if (lifeGrid[r][c] === 1) {
                    lifeCtx.fillStyle = '#61afef';
                    lifeCtx.fillRect(c * cellW + 1, r * cellH + 1, cellW - 2, cellH - 2);
                }
            }
        }
    }

    function animateLife() {
        if (!lifePlaying) return;
        stepLife();
        drawLife();
        lifeAnimId = setTimeout(() => requestAnimationFrame(animateLife), 100);
    }

    // ==========================================
    // PENDULUM SIMULATION
    // ==========================================
    let pendAnimId = null;
    let pendState = { theta: 0.5, omega: 0 };
    let pendTrail = [];

    function initPendulum() {
        const theta0 = parseFloat(document.getElementById('pend-theta0')?.value || 0.5);
        document.getElementById('pend-theta0-val').textContent = theta0.toFixed(1);
        pendState = { theta: theta0, omega: 0 };
        pendTrail = [];
        if (pendAnimId) cancelAnimationFrame(pendAnimId);
        animatePendulum();
    }

    function animatePendulum() {
        const g = 9.8, L = 1;
        const dt = 0.02;

        // RK4
        const f = (th, om) => [om, -(g/L) * Math.sin(th)];
        const k1 = f(pendState.theta, pendState.omega);
        const k2 = f(pendState.theta + dt/2 * k1[0], pendState.omega + dt/2 * k1[1]);
        const k3 = f(pendState.theta + dt/2 * k2[0], pendState.omega + dt/2 * k2[1]);
        const k4 = f(pendState.theta + dt * k3[0], pendState.omega + dt * k3[1]);

        pendState.theta += dt/6 * (k1[0] + 2*k2[0] + 2*k3[0] + k4[0]);
        pendState.omega += dt/6 * (k1[1] + 2*k2[1] + 2*k3[1] + k4[1]);

        pendTrail.push({ theta: pendState.theta, omega: pendState.omega });
        if (pendTrail.length > 300) pendTrail.shift();

        drawPendulum();
        drawPhaseSpace();
        pendAnimId = requestAnimationFrame(animatePendulum);
    }

    function drawPendulum() {
        const svg = document.getElementById('pendulum-viz');
        if (!svg) return;

        const size = 250;
        const cx = size / 2, cy = size / 2 - 20;
        const L = 80;

        svg.innerHTML = '';

        // Pivot
        const pivot = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
        pivot.setAttribute('cx', cx); pivot.setAttribute('cy', cy);
        pivot.setAttribute('r', 5); pivot.setAttribute('fill', '#888');
        svg.appendChild(pivot);

        // Rod
        const bobX = cx + L * Math.sin(pendState.theta);
        const bobY = cy + L * Math.cos(pendState.theta);

        const rod = document.createElementNS('http://www.w3.org/2000/svg', 'line');
        rod.setAttribute('x1', cx); rod.setAttribute('y1', cy);
        rod.setAttribute('x2', bobX); rod.setAttribute('y2', bobY);
        rod.setAttribute('stroke', '#ccc'); rod.setAttribute('stroke-width', 3);
        svg.appendChild(rod);

        // Bob
        const bob = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
        bob.setAttribute('cx', bobX); bob.setAttribute('cy', bobY);
        bob.setAttribute('r', 15); bob.setAttribute('fill', '#61afef');
        svg.appendChild(bob);
    }

    function drawPhaseSpace() {
        const svg = document.getElementById('phase-viz');
        if (!svg) return;

        const width = 400, height = 300;
        const margin = { top: 20, right: 20, bottom: 35, left: 45 };
        const plotW = width - margin.left - margin.right;
        const plotH = height - margin.top - margin.bottom;

        svg.innerHTML = '';

        const g = document.createElementNS('http://www.w3.org/2000/svg', 'g');
        g.setAttribute('transform', `translate(${margin.left}, ${margin.top})`);
        svg.appendChild(g);

        // Axes
        const xAxis = document.createElementNS('http://www.w3.org/2000/svg', 'line');
        xAxis.setAttribute('x1', 0); xAxis.setAttribute('y1', plotH / 2);
        xAxis.setAttribute('x2', plotW); xAxis.setAttribute('y2', plotH / 2);
        xAxis.setAttribute('stroke', '#666'); xAxis.setAttribute('stroke-width', 1);
        g.appendChild(xAxis);

        const yAxis = document.createElementNS('http://www.w3.org/2000/svg', 'line');
        yAxis.setAttribute('x1', plotW / 2); yAxis.setAttribute('y1', 0);
        yAxis.setAttribute('x2', plotW / 2); yAxis.setAttribute('y2', plotH);
        yAxis.setAttribute('stroke', '#666'); yAxis.setAttribute('stroke-width', 1);
        g.appendChild(yAxis);

        // Labels
        const xLabel = document.createElementNS('http://www.w3.org/2000/svg', 'text');
        xLabel.setAttribute('x', plotW); xLabel.setAttribute('y', plotH / 2 - 5);
        xLabel.setAttribute('fill', '#7ee8f3'); xLabel.setAttribute('text-anchor', 'end');
        xLabel.setAttribute('font-size', '16px');
        xLabel.textContent = 'Œ∏';
        g.appendChild(xLabel);

        const yLabel = document.createElementNS('http://www.w3.org/2000/svg', 'text');
        yLabel.setAttribute('x', plotW / 2 + 5); yLabel.setAttribute('y', 15);
        yLabel.setAttribute('fill', '#f5d990'); yLabel.setAttribute('font-size', '16px');
        yLabel.textContent = 'œâ';
        g.appendChild(yLabel);

        if (pendTrail.length < 2) return;

        const scale = plotW / (2 * Math.PI);
        const omegaScale = plotH / 20;

        // Trail
        let path = '';
        pendTrail.forEach((pt, i) => {
            const x = plotW / 2 + pt.theta * scale;
            const y = plotH / 2 - pt.omega * omegaScale;
            path += (i === 0 ? 'M' : 'L') + `${x},${y}`;
        });
        const curve = document.createElementNS('http://www.w3.org/2000/svg', 'path');
        curve.setAttribute('d', path);
        curve.setAttribute('stroke', '#98c379');
        curve.setAttribute('stroke-width', 2);
        curve.setAttribute('fill', 'none');
        g.appendChild(curve);

        // Current point
        const last = pendTrail[pendTrail.length - 1];
        const dot = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
        dot.setAttribute('cx', plotW / 2 + last.theta * scale);
        dot.setAttribute('cy', plotH / 2 - last.omega * omegaScale);
        dot.setAttribute('r', 5);
        dot.setAttribute('fill', '#e5c07b');
        g.appendChild(dot);
    }

    function drawPhaseFlow() {
        const svg = document.getElementById('phase-flow-viz');
        if (!svg) return;

        const width = 700, height = 350;
        const margin = { top: 20, right: 20, bottom: 40, left: 50 };
        const plotW = width - margin.left - margin.right;
        const plotH = height - margin.top - margin.bottom;

        svg.innerHTML = '';

        const g = document.createElementNS('http://www.w3.org/2000/svg', 'g');
        g.setAttribute('transform', `translate(${margin.left}, ${margin.top})`);
        svg.appendChild(g);

        // Axes
        const xAxis = document.createElementNS('http://www.w3.org/2000/svg', 'line');
        xAxis.setAttribute('x1', 0); xAxis.setAttribute('y1', plotH / 2);
        xAxis.setAttribute('x2', plotW); xAxis.setAttribute('y2', plotH / 2);
        xAxis.setAttribute('stroke', '#666'); xAxis.setAttribute('stroke-width', 1.5);
        g.appendChild(xAxis);

        const yAxis = document.createElementNS('http://www.w3.org/2000/svg', 'line');
        yAxis.setAttribute('x1', plotW / 2); yAxis.setAttribute('y1', 0);
        yAxis.setAttribute('x2', plotW / 2); yAxis.setAttribute('y2', plotH);
        yAxis.setAttribute('stroke', '#666'); yAxis.setAttribute('stroke-width', 1.5);
        g.appendChild(yAxis);

        // Labels
        const xLabel = document.createElementNS('http://www.w3.org/2000/svg', 'text');
        xLabel.setAttribute('x', plotW / 2); xLabel.setAttribute('y', plotH + 30);
        xLabel.setAttribute('fill', '#7ee8f3'); xLabel.setAttribute('text-anchor', 'middle');
        xLabel.setAttribute('font-size', '14px');
        xLabel.textContent = 'Œ∏';
        g.appendChild(xLabel);

        const yLabel = document.createElementNS('http://www.w3.org/2000/svg', 'text');
        yLabel.setAttribute('x', -plotH / 2); yLabel.setAttribute('y', -35);
        yLabel.setAttribute('fill', '#f5d990'); yLabel.setAttribute('text-anchor', 'middle');
        yLabel.setAttribute('transform', 'rotate(-90)');
        yLabel.setAttribute('font-size', '14px');
        yLabel.textContent = 'dŒ∏/dt';
        g.appendChild(yLabel);

        // Draw multiple trajectories
        const grav = 9.8, L = 1;
        const theta0s = [0.3, 0.6, 1.0, 1.5, 2.0, 2.5, 2.9];
        const colors = ['#61afef', '#98c379', '#e5c07b', '#e06c75', '#c678dd', '#56b6c2', '#abb2bf'];

        theta0s.forEach((th0, idx) => {
            let theta = th0, omega = 0;
            const dt = 0.02;
            let path = '';

            for (let i = 0; i < 500; i++) {
                const x = plotW / 2 + theta * (plotW / (2 * Math.PI));
                const y = plotH / 2 - omega * (plotH / 20);
                path += (i === 0 ? 'M' : 'L') + `${x},${y}`;

                // RK4 step
                const f = (th, om) => [om, -(grav/L) * Math.sin(th)];
                const k1 = f(theta, omega);
                const k2 = f(theta + dt/2 * k1[0], omega + dt/2 * k1[1]);
                const k3 = f(theta + dt/2 * k2[0], omega + dt/2 * k2[1]);
                const k4 = f(theta + dt * k3[0], omega + dt * k3[1]);
                theta += dt/6 * (k1[0] + 2*k2[0] + 2*k3[0] + k4[0]);
                omega += dt/6 * (k1[1] + 2*k2[1] + 2*k3[1] + k4[1]);
            }

            const curve = document.createElementNS('http://www.w3.org/2000/svg', 'path');
            curve.setAttribute('d', path);
            curve.setAttribute('stroke', colors[idx]);
            curve.setAttribute('stroke-width', 2);
            curve.setAttribute('fill', 'none');
            curve.setAttribute('opacity', '0.7');
            g.appendChild(curve);
        });
    }

    // ==========================================
    // PDE GRID VISUALIZATION
    // ==========================================
    let pdeGrid = [];
    let pdeTimeStep = 0;
    let pdeSpaceIdx = 1; // Current stencil position in space (1 to pdeNx-2)
    let pdeCurrentRow = []; // Row being built
    const pdeNx = 15;
    const pdeNt = 20;
    const pdeD = 0.4;
    const pdeDx = 1 / (pdeNx - 1);
    const pdeDt = 0.4 * pdeDx * pdeDx / pdeD;
    const pdeR = pdeD * pdeDt / (pdeDx * pdeDx);

    function initPDEGrid() {
        pdeGrid = [];
        pdeTimeStep = 0;
        pdeSpaceIdx = 1;
        pdeCurrentRow = [];

        // Initial condition: Gaussian
        const row = [];
        for (let i = 0; i < pdeNx; i++) {
            const x = i / (pdeNx - 1);
            row.push(Math.exp(-Math.pow((x - 0.5) * 5, 2)));
        }
        pdeGrid.push(row);
        pdeCurrentRow = [0]; // Start with BC

        drawPDEGrid();
        drawPDEColorbar();
        updatePDEFormula(null);
    }

    function pdeStepStencil() {
        if (pdeTimeStep >= pdeNt - 1) return;

        const prev = pdeGrid[pdeGrid.length - 1];

        if (pdeSpaceIdx < pdeNx - 1) {
            // Compute this cell
            const i = pdeSpaceIdx;
            const newVal = prev[i] + pdeR * (prev[i+1] - 2*prev[i] + prev[i-1]);
            pdeCurrentRow.push(newVal);

            // Update formula display
            updatePDEFormula({
                i: i,
                n: pdeTimeStep,
                uPrev: prev[i-1],
                uCurr: prev[i],
                uNext: prev[i+1],
                uNew: newVal,
                r: pdeR
            });

            pdeSpaceIdx++;
        }

        // Check if row is complete
        if (pdeSpaceIdx >= pdeNx - 1) {
            pdeCurrentRow.push(0); // Right BC
            pdeGrid.push([...pdeCurrentRow]);
            pdeTimeStep++;
            pdeSpaceIdx = 1;
            pdeCurrentRow = [0]; // Start new row with left BC
        }

        drawPDEGrid();
    }

    function pdeStepRow() {
        if (pdeTimeStep >= pdeNt - 1) return;

        // Complete the current row
        const prev = pdeGrid[pdeGrid.length - 1];
        pdeCurrentRow = [0]; // Left BC

        for (let i = 1; i < pdeNx - 1; i++) {
            pdeCurrentRow.push(prev[i] + pdeR * (prev[i+1] - 2*prev[i] + prev[i-1]));
        }
        pdeCurrentRow.push(0); // Right BC

        pdeGrid.push([...pdeCurrentRow]);
        pdeTimeStep++;
        pdeSpaceIdx = 1;
        pdeCurrentRow = [0];

        updatePDEFormula(null);
        drawPDEGrid();
    }

    function pdeStepBack() {
        if (pdeGrid.length <= 1) return;
        pdeGrid.pop();
        pdeTimeStep--;
        pdeSpaceIdx = 1;
        pdeCurrentRow = [0];
        updatePDEFormula(null);
        drawPDEGrid();
    }

    function pdeReset() {
        initPDEGrid();
    }

    function updatePDEFormula(data) {
        const box = document.getElementById('pde-formula-box');
        if (!box) return;

        if (!data) {
            box.innerHTML = `
                <div style="margin-bottom: 8px;"><strong>Current stencil:</strong></div>
                <div style="color: #888;">Click "Step Stencil" to begin...</div>
                <div style="margin-top: 10px; color: #61afef;">r = ${pdeR.toFixed(3)}</div>
            `;
        } else {
            const Œîu = (data.uNext - 2*data.uCurr + data.uPrev).toFixed(3);
            box.innerHTML = `
                <div style="margin-bottom: 5px;"><strong>u<sub>${data.i}</sub><sup>${data.n+1}</sup>:</strong></div>
                <div style="font-size: 0.8em; white-space: nowrap;">
                    = u<sub>${data.i}</sub><sup>${data.n}</sup> + r¬∑Œî¬≤u
                </div>
                <div style="font-size: 0.75em; color: #aaa; margin-top: 5px;">
                    = ${data.uCurr.toFixed(3)} + ${pdeR.toFixed(2)}¬∑(${Œîu})
                </div>
                <div style="margin-top: 8px; color: #98c379; font-size: 1.1em; font-weight: bold;">
                    = ${data.uNew.toFixed(4)}
                </div>
            `;
        }
    }

    function drawPDEColorbar() {
        const svg = document.getElementById('pde-colorbar');
        if (!svg) return;

        svg.innerHTML = '';
        const width = 200, height = 20;

        // Gradient bar
        for (let i = 0; i < width; i++) {
            const val = i / width;
            const intensity = Math.floor(val * 255);
            const rect = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
            rect.setAttribute('x', i);
            rect.setAttribute('y', 0);
            rect.setAttribute('width', 1);
            rect.setAttribute('height', height);
            rect.setAttribute('fill', `rgb(${intensity}, ${Math.floor(intensity * 0.7)}, ${255 - intensity})`);
            svg.appendChild(rect);
        }

        // Labels
        [0, 0.5, 1].forEach(val => {
            const x = val * width;
            const label = document.createElementNS('http://www.w3.org/2000/svg', 'text');
            label.setAttribute('x', x);
            label.setAttribute('y', height + 10);
            label.setAttribute('fill', '#888');
            label.setAttribute('text-anchor', val === 0 ? 'start' : (val === 1 ? 'end' : 'middle'));
            label.setAttribute('font-size', '9px');
            label.textContent = val.toFixed(1);
            svg.appendChild(label);
        });
    }

    function drawPDEGrid() {
        const svg = document.getElementById('pde-grid-viz');
        if (!svg) return;

        const width = 550, height = 320;
        const margin = { top: 30, right: 20, bottom: 50, left: 50 };
        const plotW = width - margin.left - margin.right;
        const plotH = height - margin.top - margin.bottom;

        svg.innerHTML = '';

        const g = document.createElementNS('http://www.w3.org/2000/svg', 'g');
        g.setAttribute('transform', `translate(${margin.left}, ${margin.top})`);
        svg.appendChild(g);

        const cellW = plotW / pdeNx;
        const cellH = plotH / pdeNt;

        // Draw completed grid cells
        for (let t = 0; t < pdeGrid.length; t++) {
            for (let i = 0; i < pdeNx; i++) {
                const val = pdeGrid[t][i];
                const rect = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
                rect.setAttribute('x', i * cellW);
                rect.setAttribute('y', plotH - (t + 1) * cellH);
                rect.setAttribute('width', cellW - 1);
                rect.setAttribute('height', cellH - 1);

                const intensity = Math.min(255, Math.floor(val * 255));
                rect.setAttribute('fill', `rgb(${intensity}, ${Math.floor(intensity * 0.7)}, ${255 - intensity})`);
                rect.setAttribute('stroke', 'rgba(255,255,255,0.1)');
                g.appendChild(rect);
            }
        }

        // Draw current row being built (only if we've computed at least one interior cell)
        if (pdeCurrentRow.length > 1 && pdeTimeStep < pdeNt - 1) {
            const t = pdeGrid.length;
            for (let i = 0; i < pdeCurrentRow.length; i++) {
                const val = pdeCurrentRow[i];
                const rect = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
                rect.setAttribute('x', i * cellW);
                rect.setAttribute('y', plotH - (t + 1) * cellH);
                rect.setAttribute('width', cellW - 1);
                rect.setAttribute('height', cellH - 1);

                const intensity = Math.min(255, Math.floor(val * 255));
                rect.setAttribute('fill', `rgb(${intensity}, ${Math.floor(intensity * 0.7)}, ${255 - intensity})`);
                // Only show green border for computed interior cells, not the boundary
                if (i > 0) {
                    rect.setAttribute('stroke', '#98c379');
                    rect.setAttribute('stroke-width', 2);
                } else {
                    rect.setAttribute('stroke', 'rgba(255,255,255,0.1)');
                }
                g.appendChild(rect);
            }
        }

        // Highlight current stencil
        if (pdeTimeStep < pdeNt - 1 && pdeSpaceIdx < pdeNx - 1) {
            const t = pdeGrid.length - 1;
            const i = pdeSpaceIdx;

            // Source cells (previous row)
            [-1, 0, 1].forEach(di => {
                const rect = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
                rect.setAttribute('x', (i + di) * cellW);
                rect.setAttribute('y', plotH - (t + 1) * cellH);
                rect.setAttribute('width', cellW - 1);
                rect.setAttribute('height', cellH - 1);
                rect.setAttribute('fill', 'none');
                rect.setAttribute('stroke', '#61afef');
                rect.setAttribute('stroke-width', 2);
                g.appendChild(rect);
            });

            // Target cell
            const targetRect = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
            targetRect.setAttribute('x', i * cellW);
            targetRect.setAttribute('y', plotH - (t + 2) * cellH);
            targetRect.setAttribute('width', cellW - 1);
            targetRect.setAttribute('height', cellH - 1);
            targetRect.setAttribute('fill', 'rgba(152, 195, 121, 0.3)');
            targetRect.setAttribute('stroke', '#98c379');
            targetRect.setAttribute('stroke-width', 2);
            g.appendChild(targetRect);
        }

        // Axis labels
        const xLabel = document.createElementNS('http://www.w3.org/2000/svg', 'text');
        xLabel.setAttribute('x', plotW / 2); xLabel.setAttribute('y', plotH + 35);
        xLabel.setAttribute('fill', '#7ee8f3'); xLabel.setAttribute('text-anchor', 'middle');
        xLabel.setAttribute('font-size', '16px');
        xLabel.textContent = 'Space index i';
        g.appendChild(xLabel);

        const yLabel = document.createElementNS('http://www.w3.org/2000/svg', 'text');
        yLabel.setAttribute('x', -plotH / 2); yLabel.setAttribute('y', -35);
        yLabel.setAttribute('fill', '#f5d990'); yLabel.setAttribute('text-anchor', 'middle');
        yLabel.setAttribute('transform', 'rotate(-90)');
        yLabel.setAttribute('font-size', '16px');
        yLabel.textContent = 'Time step n';
        g.appendChild(yLabel);

        // Status
        const stepText = document.createElementNS('http://www.w3.org/2000/svg', 'text');
        stepText.setAttribute('x', plotW - 5); stepText.setAttribute('y', -10);
        stepText.setAttribute('fill', '#ccc'); stepText.setAttribute('text-anchor', 'end');
        stepText.setAttribute('font-size', '11px');
        stepText.textContent = `n=${pdeTimeStep}, i=${pdeSpaceIdx}`;
        g.appendChild(stepText);
    }

    // ==========================================
    // CFL STABILITY DEMONSTRATION
    // ==========================================
    function initCFLDemo() {
        drawCFLDemo();
    }

    function runCFLDemo() {
        const r = parseFloat(document.getElementById('cfl-r')?.value || 0.4);
        document.getElementById('cfl-r-val').textContent = r.toFixed(2);

        // Run simulation
        const nx = 30;
        const nt = 50;
        let u = [];

        // Initial condition: Gaussian
        for (let i = 0; i < nx; i++) {
            const x = i / (nx - 1);
            u.push(Math.exp(-Math.pow((x - 0.5) * 5, 2)));
        }

        const history = [u.slice()];

        for (let n = 0; n < nt; n++) {
            const uNew = [0]; // Left BC
            for (let i = 1; i < nx - 1; i++) {
                const val = u[i] + r * (u[i+1] - 2*u[i] + u[i-1]);
                uNew.push(val);
            }
            uNew.push(0); // Right BC
            u = uNew;
            history.push(u.slice());

            // Check for blowup
            const maxU = Math.max(...u.map(Math.abs));
            if (maxU > 100) break;
        }

        drawCFLDemo(history, r);

        // Update status
        const statusBox = document.getElementById('cfl-status');
        if (r <= 0.5) {
            statusBox.className = 'success-box small-text';
            statusBox.innerHTML = `<strong>r = ${r.toFixed(2)}:</strong> Stable ‚úì<br>Solution remains bounded`;
        } else {
            statusBox.className = 'warning-box small-text';
            statusBox.innerHTML = `<strong>r = ${r.toFixed(2)}:</strong> UNSTABLE ‚úó<br>Solution blows up!`;
        }
    }

    function drawCFLDemo(history, r) {
        const svg = document.getElementById('cfl-demo-viz');
        if (!svg) return;

        const width = 500, height = 320;
        const margin = { top: 20, right: 100, bottom: 40, left: 50 };
        const plotW = width - margin.left - margin.right;
        const plotH = height - margin.top - margin.bottom;

        svg.innerHTML = '';

        const g = document.createElementNS('http://www.w3.org/2000/svg', 'g');
        g.setAttribute('transform', `translate(${margin.left}, ${margin.top})`);
        svg.appendChild(g);

        // Axes
        const xAxis = document.createElementNS('http://www.w3.org/2000/svg', 'line');
        xAxis.setAttribute('x1', 0); xAxis.setAttribute('y1', plotH);
        xAxis.setAttribute('x2', plotW); xAxis.setAttribute('y2', plotH);
        xAxis.setAttribute('stroke', '#666'); xAxis.setAttribute('stroke-width', 1);
        g.appendChild(xAxis);

        const yAxis = document.createElementNS('http://www.w3.org/2000/svg', 'line');
        yAxis.setAttribute('x1', 0); yAxis.setAttribute('y1', 0);
        yAxis.setAttribute('x2', 0); yAxis.setAttribute('y2', plotH);
        yAxis.setAttribute('stroke', '#666'); yAxis.setAttribute('stroke-width', 1);
        g.appendChild(yAxis);

        // Labels
        const xLabel = document.createElementNS('http://www.w3.org/2000/svg', 'text');
        xLabel.setAttribute('x', plotW / 2); xLabel.setAttribute('y', plotH + 30);
        xLabel.setAttribute('fill', '#7ee8f3'); xLabel.setAttribute('text-anchor', 'middle');
        xLabel.setAttribute('font-size', '16px');
        xLabel.textContent = 'Space (x)';
        g.appendChild(xLabel);

        const yLabel = document.createElementNS('http://www.w3.org/2000/svg', 'text');
        yLabel.setAttribute('x', -plotH / 2); yLabel.setAttribute('y', -35);
        yLabel.setAttribute('fill', '#f5d990'); yLabel.setAttribute('text-anchor', 'middle');
        yLabel.setAttribute('transform', 'rotate(-90)');
        yLabel.setAttribute('font-size', '16px');
        yLabel.textContent = 'u(x,t)';
        g.appendChild(yLabel);

        if (!history) return;

        const nx = history[0].length;
        const yMax = r > 0.5 ? 5 : 1.2;
        const yMin = r > 0.5 ? -5 : -0.2;

        // Brighter colors and time labels for legend
        const colors = ['#8dd3ff', '#b8e994', '#ffd93d', '#ff6b6b', '#dda0dd'];
        const timeLabels = ['t=0', 't=0.25T', 't=0.5T', 't=0.75T', 't=T'];
        const times = [0, Math.floor(history.length * 0.25), Math.floor(history.length * 0.5),
                       Math.floor(history.length * 0.75), history.length - 1];

        times.forEach((t, idx) => {
            if (t >= history.length) return;
            const u = history[t];
            let path = '';

            u.forEach((val, i) => {
                const px = (i / (nx - 1)) * plotW;
                const py = plotH - ((Math.min(Math.max(val, yMin), yMax) - yMin) / (yMax - yMin)) * plotH;
                path += (i === 0 ? 'M' : 'L') + `${px},${py}`;
            });

            const curve = document.createElementNS('http://www.w3.org/2000/svg', 'path');
            curve.setAttribute('d', path);
            curve.setAttribute('stroke', colors[idx]);
            curve.setAttribute('stroke-width', 2.5);
            curve.setAttribute('fill', 'none');
            curve.setAttribute('opacity', 0.9);
            g.appendChild(curve);
        });

        // Time legend
        times.forEach((t, idx) => {
            const legendY = 20 + idx * 22;
            const legendX = plotW + 15;

            const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
            line.setAttribute('x1', legendX); line.setAttribute('y1', legendY);
            line.setAttribute('x2', legendX + 25); line.setAttribute('y2', legendY);
            line.setAttribute('stroke', colors[idx]);
            line.setAttribute('stroke-width', 2.5);
            g.appendChild(line);

            const label = document.createElementNS('http://www.w3.org/2000/svg', 'text');
            label.setAttribute('x', legendX + 30); label.setAttribute('y', legendY + 4);
            label.setAttribute('fill', colors[idx]);
            label.setAttribute('font-size', '11px');
            label.textContent = timeLabels[idx];
            g.appendChild(label);
        });

        // Zero line
        if (r > 0.5) {
            const zeroY = plotH - ((0 - yMin) / (yMax - yMin)) * plotH;
            const zeroLine = document.createElementNS('http://www.w3.org/2000/svg', 'line');
            zeroLine.setAttribute('x1', 0); zeroLine.setAttribute('y1', zeroY);
            zeroLine.setAttribute('x2', plotW); zeroLine.setAttribute('y2', zeroY);
            zeroLine.setAttribute('stroke', '#888'); zeroLine.setAttribute('stroke-dasharray', '4,4');
            g.appendChild(zeroLine);
        }
    }

    // ==========================================
    // 2D FLUID SIMULATOR
    // ==========================================
    let fluidCanvas, fluidCtx;
    let fluidN = 64;
    let fluidDt = 0.1;
    let fluidDiff = 0.00005;
    let fluidVisc = 0.00005;
    let fluidU, fluidV, fluidU0, fluidV0;
    let fluidDens, fluidDens0;
    let fluidMouseX = -1, fluidMouseY = -1;
    let fluidMouseDown = false;
    let fluidAnimId = null;

    function IX(i, j) { return i + (fluidN + 2) * j; }

    function initFluid() {
        fluidCanvas = document.getElementById('fluid-canvas');
        if (!fluidCanvas) return;
        fluidCtx = fluidCanvas.getContext('2d');

        // Read initial slider values
        fluidVisc = parseFloat(document.getElementById('fluid-visc')?.value || 0.0001);
        fluidDiff = parseFloat(document.getElementById('fluid-diff')?.value || 0.0001);

        const size = (fluidN + 2) * (fluidN + 2);
        fluidU = new Float32Array(size);
        fluidV = new Float32Array(size);
        fluidU0 = new Float32Array(size);
        fluidV0 = new Float32Array(size);
        fluidDens = new Float32Array(size);
        fluidDens0 = new Float32Array(size);

        fluidCanvas.addEventListener('mousemove', (e) => {
            const rect = fluidCanvas.getBoundingClientRect();
            fluidMouseX = (e.clientX - rect.left) / rect.width;
            fluidMouseY = (e.clientY - rect.top) / rect.height;
        });

        fluidCanvas.addEventListener('mousedown', () => { fluidMouseDown = true; });
        fluidCanvas.addEventListener('mouseup', () => { fluidMouseDown = false; });
        fluidCanvas.addEventListener('mouseleave', () => { fluidMouseX = -1; fluidMouseY = -1; });

        if (fluidAnimId) cancelAnimationFrame(fluidAnimId);
        animateFluid();
    }

    function addSource(x, s, dt) {
        for (let i = 0; i < x.length; i++) x[i] += dt * s[i];
    }

    function setBnd(b, x) {
        for (let i = 1; i <= fluidN; i++) {
            x[IX(0, i)] = b === 1 ? -x[IX(1, i)] : x[IX(1, i)];
            x[IX(fluidN + 1, i)] = b === 1 ? -x[IX(fluidN, i)] : x[IX(fluidN, i)];
            x[IX(i, 0)] = b === 2 ? -x[IX(i, 1)] : x[IX(i, 1)];
            x[IX(i, fluidN + 1)] = b === 2 ? -x[IX(i, fluidN)] : x[IX(i, fluidN)];
        }
        x[IX(0, 0)] = 0.5 * (x[IX(1, 0)] + x[IX(0, 1)]);
        x[IX(0, fluidN + 1)] = 0.5 * (x[IX(1, fluidN + 1)] + x[IX(0, fluidN)]);
        x[IX(fluidN + 1, 0)] = 0.5 * (x[IX(fluidN, 0)] + x[IX(fluidN + 1, 1)]);
        x[IX(fluidN + 1, fluidN + 1)] = 0.5 * (x[IX(fluidN, fluidN + 1)] + x[IX(fluidN + 1, fluidN)]);
    }

    function linSolve(b, x, x0, a, c) {
        for (let k = 0; k < 4; k++) {
            for (let i = 1; i <= fluidN; i++) {
                for (let j = 1; j <= fluidN; j++) {
                    x[IX(i, j)] = (x0[IX(i, j)] + a * (x[IX(i - 1, j)] + x[IX(i + 1, j)] + x[IX(i, j - 1)] + x[IX(i, j + 1)])) / c;
                }
            }
            setBnd(b, x);
        }
    }

    function diffuse(b, x, x0, diff, dt) {
        const a = dt * diff * fluidN * fluidN;
        linSolve(b, x, x0, a, 1 + 4 * a);
    }

    function advect(b, d, d0, u, v, dt) {
        const dt0 = dt * fluidN;
        for (let i = 1; i <= fluidN; i++) {
            for (let j = 1; j <= fluidN; j++) {
                let x = i - dt0 * u[IX(i, j)];
                let y = j - dt0 * v[IX(i, j)];
                x = Math.max(0.5, Math.min(fluidN + 0.5, x));
                y = Math.max(0.5, Math.min(fluidN + 0.5, y));
                const i0 = Math.floor(x), i1 = i0 + 1;
                const j0 = Math.floor(y), j1 = j0 + 1;
                const s1 = x - i0, s0 = 1 - s1;
                const t1 = y - j0, t0 = 1 - t1;
                d[IX(i, j)] = s0 * (t0 * d0[IX(i0, j0)] + t1 * d0[IX(i0, j1)]) + s1 * (t0 * d0[IX(i1, j0)] + t1 * d0[IX(i1, j1)]);
            }
        }
        setBnd(b, d);
    }

    function project(u, v, p, div) {
        for (let i = 1; i <= fluidN; i++) {
            for (let j = 1; j <= fluidN; j++) {
                div[IX(i, j)] = -0.5 * (u[IX(i + 1, j)] - u[IX(i - 1, j)] + v[IX(i, j + 1)] - v[IX(i, j - 1)]) / fluidN;
                p[IX(i, j)] = 0;
            }
        }
        setBnd(0, div);
        setBnd(0, p);
        linSolve(0, p, div, 1, 4);
        for (let i = 1; i <= fluidN; i++) {
            for (let j = 1; j <= fluidN; j++) {
                u[IX(i, j)] -= 0.5 * fluidN * (p[IX(i + 1, j)] - p[IX(i - 1, j)]);
                v[IX(i, j)] -= 0.5 * fluidN * (p[IX(i, j + 1)] - p[IX(i, j - 1)]);
            }
        }
        setBnd(1, u);
        setBnd(2, v);
    }

    function velStep(u, v, u0, v0, visc, dt) {
        addSource(u, u0, dt);
        addSource(v, v0, dt);
        [u0, u] = [u, u0];
        diffuse(1, u, u0, visc, dt);
        [v0, v] = [v, v0];
        diffuse(2, v, v0, visc, dt);
        project(u, v, u0, v0);
        [u0, u] = [u, u0];
        [v0, v] = [v, v0];
        advect(1, u, u0, u0, v0, dt);
        advect(2, v, v0, u0, v0, dt);
        project(u, v, u0, v0);
    }

    function densStep(x, x0, u, v, diff, dt) {
        addSource(x, x0, dt);
        [x0, x] = [x, x0];
        diffuse(0, x, x0, diff, dt);
        [x0, x] = [x, x0];
        advect(0, x, x0, u, v, dt);
    }

    function animateFluid() {
        // Read slider values
        fluidVisc = parseFloat(document.getElementById('fluid-visc')?.value || 0.0001);
        fluidDiff = parseFloat(document.getElementById('fluid-diff')?.value || 0.0001);
        const flowRate = parseFloat(document.getElementById('fluid-flow')?.value || 15);

        // Update flow display
        if (document.getElementById('fluid-flow-val'))
            document.getElementById('fluid-flow-val').textContent = flowRate;

        // Clear sources
        fluidU0.fill(0);
        fluidV0.fill(0);
        fluidDens0.fill(0);

        // Add constant RED source at top (controllable)
        const sourceWidth = Math.floor(fluidN / 4);
        const sourceStart = Math.floor(fluidN / 2 - sourceWidth / 2);
        for (let ii = sourceStart; ii < sourceStart + sourceWidth; ii++) {
            fluidDens0[IX(ii, 3)] += flowRate;  // Controllable source
            fluidV0[IX(ii, 3)] = flowRate * 0.5;  // Push downward
        }

        // Mouse acts as OBSTACLE (blocks flow by setting velocity to zero)
        if (fluidMouseX >= 0 && fluidMouseX <= 1 && fluidMouseY >= 0 && fluidMouseY <= 1) {
            const mi = Math.floor(fluidMouseX * fluidN) + 1;
            const mj = Math.floor((1 - fluidMouseY) * fluidN) + 1;  // Flip Y for screen coords
            // Set velocity to zero in a small region around mouse
            for (let di = -2; di <= 2; di++) {
                for (let dj = -2; dj <= 2; dj++) {
                    const ii = mi + di;
                    const jj = mj + dj;
                    if (ii > 0 && ii <= fluidN && jj > 0 && jj <= fluidN) {
                        fluidU[IX(ii, jj)] = 0;
                        fluidV[IX(ii, jj)] = 0;
                        fluidDens[IX(ii, jj)] *= 0.5;  // Reduce density too
                    }
                }
            }
        }

        velStep(fluidU, fluidV, fluidU0, fluidV0, fluidVisc, fluidDt);
        densStep(fluidDens, fluidDens0, fluidU, fluidV, fluidDiff, fluidDt);

        drawFluid();
        fluidAnimId = requestAnimationFrame(animateFluid);
    }

    function drawFluid() {
        if (!fluidCtx) return;

        const w = fluidCanvas.width;
        const h = fluidCanvas.height;
        const cellW = w / fluidN;
        const cellH = h / fluidN;

        const imgData = fluidCtx.createImageData(w, h);

        for (let i = 0; i < fluidN; i++) {
            for (let j = 0; j < fluidN; j++) {
                const d = Math.min(255, fluidDens[IX(i + 1, fluidN + 1 - j)] * 8);  // Flip Y

                const x0 = Math.floor(i * cellW);
                const y0 = Math.floor(j * cellH);
                const x1 = Math.floor((i + 1) * cellW);
                const y1 = Math.floor((j + 1) * cellH);

                for (let x = x0; x < x1; x++) {
                    for (let y = y0; y < y1; y++) {
                        const idx = (y * w + x) * 4;
                        // Bright colormap: cyan ‚Üí green ‚Üí yellow ‚Üí orange ‚Üí white
                        const t = Math.min(1, d / 90);  // normalize, 2x brighter
                        let r, g, b;
                        if (t < 0.02) {
                            // Near-black background
                            r = 15; g = 20; b = 30;
                        } else if (t < 0.3) {
                            // Cyan to green
                            const s = (t - 0.02) / 0.28;
                            r = 30 + s * 50;
                            g = 180 + s * 75;
                            b = 220 - s * 120;
                        } else if (t < 0.6) {
                            // Green to yellow
                            const s = (t - 0.3) / 0.3;
                            r = 80 + s * 175;
                            g = 255;
                            b = 100 - s * 70;
                        } else if (t < 0.85) {
                            // Yellow to orange
                            const s = (t - 0.6) / 0.25;
                            r = 255;
                            g = 255 - s * 100;
                            b = 30 + s * 20;
                        } else {
                            // Orange to white
                            const s = (t - 0.85) / 0.15;
                            r = 255;
                            g = 155 + s * 100;
                            b = 50 + s * 205;
                        }
                        imgData.data[idx] = Math.min(255, r);
                        imgData.data[idx + 1] = Math.min(255, g);
                        imgData.data[idx + 2] = Math.min(255, b);
                        imgData.data[idx + 3] = 255;
                    }
                }
            }
        }

        // Draw obstacle indicator if mouse is on canvas
        if (fluidMouseX >= 0 && fluidMouseX <= 1 && fluidMouseY >= 0 && fluidMouseY <= 1) {
            const mx = Math.floor(fluidMouseX * w);
            const my = Math.floor(fluidMouseY * h);
            // Draw a small white circle at mouse position
            for (let dx = -8; dx <= 8; dx++) {
                for (let dy = -8; dy <= 8; dy++) {
                    if (dx*dx + dy*dy <= 64) {
                        const px = mx + dx;
                        const py = my + dy;
                        if (px >= 0 && px < w && py >= 0 && py < h) {
                            const idx = (py * w + px) * 4;
                            imgData.data[idx] = 255;
                            imgData.data[idx + 1] = 255;
                            imgData.data[idx + 2] = 255;
                        }
                    }
                }
            }
        }

        fluidCtx.putImageData(imgData, 0, 0);
    }

    // ==========================================
    // LORENZ SYSTEM
    // ==========================================
    let lorenzState = { x: 1, y: 1, z: 1 };
    let lorenzTrail = [];
    let lorenzAnimId = null;
    let lorenzTrailLength = 1500;
    let lorenzSpeed = 3;

    function initLorenz() {
        lorenzState = { x: 1, y: 1, z: 1 };
        lorenzTrail = [];
        lorenzTrailLength = parseInt(document.getElementById('lorenz-trail')?.value || 1500);
        lorenzSpeed = parseInt(document.getElementById('lorenz-speed')?.value || 3);
        if (lorenzAnimId) cancelAnimationFrame(lorenzAnimId);
        animateLorenz();
    }

    function animateLorenz() {
        const sigma = 10, rho = 28, beta = 8/3;
        const dt = 0.008;

        // Read parameters from sliders
        lorenzTrailLength = parseInt(document.getElementById('lorenz-trail')?.value || 1500);
        lorenzSpeed = parseInt(document.getElementById('lorenz-speed')?.value || 3);

        // Update displays
        if (document.getElementById('lorenz-speed-val'))
            document.getElementById('lorenz-speed-val').textContent = lorenzSpeed;
        if (document.getElementById('lorenz-trail-val'))
            document.getElementById('lorenz-trail-val').textContent = lorenzTrailLength;

        // RK4 integration (slower, fewer steps per frame)
        for (let step = 0; step < lorenzSpeed; step++) {
            const f = (x, y, z) => [sigma * (y - x), x * (rho - z) - y, x * y - beta * z];
            const k1 = f(lorenzState.x, lorenzState.y, lorenzState.z);
            const k2 = f(lorenzState.x + dt/2 * k1[0], lorenzState.y + dt/2 * k1[1], lorenzState.z + dt/2 * k1[2]);
            const k3 = f(lorenzState.x + dt/2 * k2[0], lorenzState.y + dt/2 * k2[1], lorenzState.z + dt/2 * k2[2]);
            const k4 = f(lorenzState.x + dt * k3[0], lorenzState.y + dt * k3[1], lorenzState.z + dt * k3[2]);

            lorenzState.x += dt/6 * (k1[0] + 2*k2[0] + 2*k3[0] + k4[0]);
            lorenzState.y += dt/6 * (k1[1] + 2*k2[1] + 2*k3[1] + k4[1]);
            lorenzState.z += dt/6 * (k1[2] + 2*k2[2] + 2*k3[2] + k4[2]);

            lorenzTrail.push({ x: lorenzState.x, y: lorenzState.y, z: lorenzState.z });
            if (lorenzTrail.length > lorenzTrailLength) lorenzTrail.shift();
        }

        // Update coordinate display
        const coordsDiv = document.getElementById('lorenz-coords');
        if (coordsDiv) {
            coordsDiv.innerHTML = `x = ${lorenzState.x.toFixed(2)}<br>y = ${lorenzState.y.toFixed(2)}<br>z = ${lorenzState.z.toFixed(2)}`;
        }

        drawLorenz();
        lorenzAnimId = requestAnimationFrame(animateLorenz);
    }

    function drawLorenz() {
        const svg = document.getElementById('lorenz-viz');
        if (!svg) return;

        const width = 500, height = 380;
        svg.innerHTML = '';

        if (lorenzTrail.length < 2) return;

        // Draw trail with fading opacity
        const segmentSize = 50;
        const numSegments = Math.ceil(lorenzTrail.length / segmentSize);

        for (let seg = 0; seg < numSegments; seg++) {
            const startIdx = seg * segmentSize;
            const endIdx = Math.min((seg + 1) * segmentSize + 1, lorenzTrail.length);
            if (endIdx - startIdx < 2) continue;

            let path = '';
            for (let i = startIdx; i < endIdx; i++) {
                const pt = lorenzTrail[i];
                // 3D to 2D projection (x-z view with slight rotation)
                const scale = 5.5;
                const px = width / 2 + (pt.x + pt.y * 0.1) * scale;
                const py = height - 40 - pt.z * scale * 0.75;
                path += (i === startIdx ? 'M' : 'L') + `${px},${py}`;
            }

            // Fade based on position in trail
            const opacity = 0.1 + 0.9 * (seg / numSegments);
            const curve = document.createElementNS('http://www.w3.org/2000/svg', 'path');
            curve.setAttribute('d', path);
            curve.setAttribute('stroke', '#61afef');
            curve.setAttribute('stroke-width', 1.5);
            curve.setAttribute('fill', 'none');
            curve.setAttribute('opacity', opacity.toFixed(2));
            svg.appendChild(curve);
        }

        // Draw current point
        const last = lorenzTrail[lorenzTrail.length - 1];
        const scale = 5.5;
        const lastX = width / 2 + (last.x + last.y * 0.1) * scale;
        const lastY = height - 40 - last.z * scale * 0.75;

        const dot = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
        dot.setAttribute('cx', lastX);
        dot.setAttribute('cy', lastY);
        dot.setAttribute('r', 4);
        dot.setAttribute('fill', '#e5c07b');
        svg.appendChild(dot);

        // Draw 3D-style axes
        const axisOriginX = 60;
        const axisOriginY = height - 50;
        const axisLen = 50;

        // X axis (pointing right)
        const xAxis = document.createElementNS('http://www.w3.org/2000/svg', 'line');
        xAxis.setAttribute('x1', axisOriginX); xAxis.setAttribute('y1', axisOriginY);
        xAxis.setAttribute('x2', axisOriginX + axisLen); xAxis.setAttribute('y2', axisOriginY);
        xAxis.setAttribute('stroke', '#e06c75'); xAxis.setAttribute('stroke-width', 2);
        svg.appendChild(xAxis);
        const xLabel = document.createElementNS('http://www.w3.org/2000/svg', 'text');
        xLabel.setAttribute('x', axisOriginX + axisLen + 5); xLabel.setAttribute('y', axisOriginY + 4);
        xLabel.setAttribute('fill', '#e06c75'); xLabel.setAttribute('font-size', '14px');
        xLabel.textContent = 'x';
        svg.appendChild(xLabel);

        // Y axis (pointing into screen, angled)
        const yAxis = document.createElementNS('http://www.w3.org/2000/svg', 'line');
        yAxis.setAttribute('x1', axisOriginX); yAxis.setAttribute('y1', axisOriginY);
        yAxis.setAttribute('x2', axisOriginX + axisLen * 0.4); yAxis.setAttribute('y2', axisOriginY - axisLen * 0.4);
        yAxis.setAttribute('stroke', '#98c379'); yAxis.setAttribute('stroke-width', 2);
        svg.appendChild(yAxis);
        const yLabel = document.createElementNS('http://www.w3.org/2000/svg', 'text');
        yLabel.setAttribute('x', axisOriginX + axisLen * 0.4 + 5); yLabel.setAttribute('y', axisOriginY - axisLen * 0.4);
        yLabel.setAttribute('fill', '#98c379'); yLabel.setAttribute('font-size', '14px');
        yLabel.textContent = 'y';
        svg.appendChild(yLabel);

        // Z axis (pointing up)
        const zAxis = document.createElementNS('http://www.w3.org/2000/svg', 'line');
        zAxis.setAttribute('x1', axisOriginX); zAxis.setAttribute('y1', axisOriginY);
        zAxis.setAttribute('x2', axisOriginX); zAxis.setAttribute('y2', axisOriginY - axisLen);
        zAxis.setAttribute('stroke', '#61afef'); zAxis.setAttribute('stroke-width', 2);
        svg.appendChild(zAxis);
        const zLabel = document.createElementNS('http://www.w3.org/2000/svg', 'text');
        zLabel.setAttribute('x', axisOriginX - 5); zLabel.setAttribute('y', axisOriginY - axisLen - 5);
        zLabel.setAttribute('fill', '#61afef'); zLabel.setAttribute('font-size', '14px');
        zLabel.textContent = 'z';
        svg.appendChild(zLabel);

        // Label
        const label = document.createElementNS('http://www.w3.org/2000/svg', 'text');
        label.setAttribute('x', width / 2); label.setAttribute('y', 20);
        label.setAttribute('fill', '#aaa'); label.setAttribute('font-size', '12px');
        label.setAttribute('text-anchor', 'middle');
        label.textContent = 'Lorenz Attractor';
        svg.appendChild(label);
    }

    function resetLorenz() {
        if (lorenzAnimId) cancelAnimationFrame(lorenzAnimId);
        initLorenz();
    }

    // Divergence visualization (for the "accident" slide)
    function initLorenzDiverge() {
        drawLorenzDiverge();
    }

    function drawLorenzDiverge() {
        const svg = document.getElementById('lorenz-diverge-viz');
        if (!svg) return;

        const width = 800, height = 300;
        const margin = { top: 20, right: 20, bottom: 40, left: 50 };
        const plotW = width - margin.left - margin.right;
        const plotH = height - margin.top - margin.bottom;

        svg.innerHTML = '';

        const g = document.createElementNS('http://www.w3.org/2000/svg', 'g');
        g.setAttribute('transform', `translate(${margin.left}, ${margin.top})`);
        svg.appendChild(g);

        // Simulate two trajectories with Lorenz's actual error
        const sigma = 10, rho = 28, beta = 8/3;
        const dt = 0.01;
        const steps = 2500;
        const eps = 0.000127; // Lorenz's rounding error

        let x1 = 1, y1 = 1, z1 = 1;
        let x2 = 1 + eps, y2 = 1, z2 = 1;

        const traj1 = [], traj2 = [];

        for (let i = 0; i < steps; i++) {
            if (i % 4 === 0) {
                traj1.push({ t: i * dt, x: x1 });
                traj2.push({ t: i * dt, x: x2 });
            }

            const f = (x, y, z) => [sigma * (y - x), x * (rho - z) - y, x * y - beta * z];

            // RK4 for traj1
            let k1 = f(x1, y1, z1);
            let k2 = f(x1 + dt/2 * k1[0], y1 + dt/2 * k1[1], z1 + dt/2 * k1[2]);
            let k3 = f(x1 + dt/2 * k2[0], y1 + dt/2 * k2[1], z1 + dt/2 * k2[2]);
            let k4 = f(x1 + dt * k3[0], y1 + dt * k3[1], z1 + dt * k3[2]);
            x1 += dt/6 * (k1[0] + 2*k2[0] + 2*k3[0] + k4[0]);
            y1 += dt/6 * (k1[1] + 2*k2[1] + 2*k3[1] + k4[1]);
            z1 += dt/6 * (k1[2] + 2*k2[2] + 2*k3[2] + k4[2]);

            // RK4 for traj2
            k1 = f(x2, y2, z2);
            k2 = f(x2 + dt/2 * k1[0], y2 + dt/2 * k1[1], z2 + dt/2 * k1[2]);
            k3 = f(x2 + dt/2 * k2[0], y2 + dt/2 * k2[1], z2 + dt/2 * k2[2]);
            k4 = f(x2 + dt * k3[0], y2 + dt * k3[1], z2 + dt * k3[2]);
            x2 += dt/6 * (k1[0] + 2*k2[0] + 2*k3[0] + k4[0]);
            y2 += dt/6 * (k1[1] + 2*k2[1] + 2*k3[1] + k4[1]);
            z2 += dt/6 * (k1[2] + 2*k2[2] + 2*k3[2] + k4[2]);
        }

        // Axes
        const xAxis = document.createElementNS('http://www.w3.org/2000/svg', 'line');
        xAxis.setAttribute('x1', 0); xAxis.setAttribute('y1', plotH / 2);
        xAxis.setAttribute('x2', plotW); xAxis.setAttribute('y2', plotH / 2);
        xAxis.setAttribute('stroke', '#666'); xAxis.setAttribute('stroke-width', 1);
        g.appendChild(xAxis);

        // Labels
        const xLabel = document.createElementNS('http://www.w3.org/2000/svg', 'text');
        xLabel.setAttribute('x', plotW / 2); xLabel.setAttribute('y', plotH + 30);
        xLabel.setAttribute('fill', '#7ee8f3'); xLabel.setAttribute('text-anchor', 'middle');
        xLabel.setAttribute('font-size', '16px');
        xLabel.textContent = 'Time';
        g.appendChild(xLabel);

        const yLabel = document.createElementNS('http://www.w3.org/2000/svg', 'text');
        yLabel.setAttribute('x', -plotH / 2); yLabel.setAttribute('y', -35);
        yLabel.setAttribute('fill', '#f5d990'); yLabel.setAttribute('text-anchor', 'middle');
        yLabel.setAttribute('transform', 'rotate(-90)');
        yLabel.setAttribute('font-size', '16px');
        yLabel.textContent = 'x(t) - "Temperature"';
        g.appendChild(yLabel);

        const tMax = traj1[traj1.length - 1].t;
        const xScale = plotW / tMax;
        const yScale = plotH / 50;

        // Draw trajectories
        [{ data: traj1, color: '#61afef', label: 'Original' },
         { data: traj2, color: '#e06c75', label: 'Restarted (0.506 vs 0.506127)' }].forEach(({ data, color }) => {
            let path = '';
            data.forEach((pt, i) => {
                const px = pt.t * xScale;
                const py = plotH / 2 - pt.x * yScale;
                path += (i === 0 ? 'M' : 'L') + `${px},${py}`;
            });
            const curve = document.createElementNS('http://www.w3.org/2000/svg', 'path');
            curve.setAttribute('d', path);
            curve.setAttribute('stroke', color);
            curve.setAttribute('stroke-width', 2);
            curve.setAttribute('fill', 'none');
            g.appendChild(curve);
        });

        // Legend
        const legend1 = document.createElementNS('http://www.w3.org/2000/svg', 'text');
        legend1.setAttribute('x', plotW - 10); legend1.setAttribute('y', 15);
        legend1.setAttribute('fill', '#61afef'); legend1.setAttribute('text-anchor', 'end');
        legend1.setAttribute('font-size', '11px');
        legend1.textContent = '‚ñ† Original run';
        g.appendChild(legend1);

        const legend2 = document.createElementNS('http://www.w3.org/2000/svg', 'text');
        legend2.setAttribute('x', plotW - 10); legend2.setAttribute('y', 30);
        legend2.setAttribute('fill', '#e06c75'); legend2.setAttribute('text-anchor', 'end');
        legend2.setAttribute('font-size', '11px');
        legend2.textContent = '‚ñ† Restarted (from printout)';
        g.appendChild(legend2);

        // Annotation for divergence
        const divX = plotW * 0.5;
        const arrow = document.createElementNS('http://www.w3.org/2000/svg', 'text');
        arrow.setAttribute('x', divX); arrow.setAttribute('y', plotH - 10);
        arrow.setAttribute('fill', '#e5c07b'); arrow.setAttribute('text-anchor', 'middle');
        arrow.setAttribute('font-size', '11px');
        arrow.textContent = '‚Üë Complete divergence!';
        g.appendChild(arrow);
    }

    function initLorenzSensitivity() {
        const svg = document.getElementById('lorenz-sensitivity-viz');
        if (!svg) return;

        updateLorenzSensitivity();
    }

    function updateLorenzSensitivity() {
        const svg = document.getElementById('lorenz-sensitivity-viz');
        if (!svg) return;

        const exp = parseFloat(document.getElementById('lorenz-perturb')?.value || -4);
        const eps = Math.pow(10, exp);
        document.getElementById('lorenz-perturb-val').innerHTML = `10<sup>${exp}</sup>`;

        const width = 800, height = 350;
        const margin = { top: 20, right: 20, bottom: 40, left: 50 };
        const plotW = width - margin.left - margin.right;
        const plotH = height - margin.top - margin.bottom;

        svg.innerHTML = '';

        const g = document.createElementNS('http://www.w3.org/2000/svg', 'g');
        g.setAttribute('transform', `translate(${margin.left}, ${margin.top})`);
        svg.appendChild(g);

        // Simulate two trajectories
        const sigma = 10, rho = 28, beta = 8/3;
        const dt = 0.01;
        const steps = 3000;

        let x1 = 1, y1 = 1, z1 = 1;
        let x2 = 1 + eps, y2 = 1, z2 = 1;

        const traj1 = [], traj2 = [];

        for (let i = 0; i < steps; i++) {
            if (i % 5 === 0) {
                traj1.push({ t: i * dt, x: x1 });
                traj2.push({ t: i * dt, x: x2 });
            }

            // RK4 for traj1
            const f1 = (x, y, z) => [sigma * (y - x), x * (rho - z) - y, x * y - beta * z];
            let k1 = f1(x1, y1, z1);
            let k2 = f1(x1 + dt/2 * k1[0], y1 + dt/2 * k1[1], z1 + dt/2 * k1[2]);
            let k3 = f1(x1 + dt/2 * k2[0], y1 + dt/2 * k2[1], z1 + dt/2 * k2[2]);
            let k4 = f1(x1 + dt * k3[0], y1 + dt * k3[1], z1 + dt * k3[2]);
            x1 += dt/6 * (k1[0] + 2*k2[0] + 2*k3[0] + k4[0]);
            y1 += dt/6 * (k1[1] + 2*k2[1] + 2*k3[1] + k4[1]);
            z1 += dt/6 * (k1[2] + 2*k2[2] + 2*k3[2] + k4[2]);

            // RK4 for traj2
            k1 = f1(x2, y2, z2);
            k2 = f1(x2 + dt/2 * k1[0], y2 + dt/2 * k1[1], z2 + dt/2 * k1[2]);
            k3 = f1(x2 + dt/2 * k2[0], y2 + dt/2 * k2[1], z2 + dt/2 * k2[2]);
            k4 = f1(x2 + dt * k3[0], y2 + dt * k3[1], z2 + dt * k3[2]);
            x2 += dt/6 * (k1[0] + 2*k2[0] + 2*k3[0] + k4[0]);
            y2 += dt/6 * (k1[1] + 2*k2[1] + 2*k3[1] + k4[1]);
            z2 += dt/6 * (k1[2] + 2*k2[2] + 2*k3[2] + k4[2]);
        }

        // Axes
        const xAxis = document.createElementNS('http://www.w3.org/2000/svg', 'line');
        xAxis.setAttribute('x1', 0); xAxis.setAttribute('y1', plotH / 2);
        xAxis.setAttribute('x2', plotW); xAxis.setAttribute('y2', plotH / 2);
        xAxis.setAttribute('stroke', '#666'); xAxis.setAttribute('stroke-width', 1);
        g.appendChild(xAxis);

        // Labels
        const xLabel = document.createElementNS('http://www.w3.org/2000/svg', 'text');
        xLabel.setAttribute('x', plotW / 2); xLabel.setAttribute('y', plotH + 30);
        xLabel.setAttribute('fill', '#7ee8f3'); xLabel.setAttribute('text-anchor', 'middle');
        xLabel.setAttribute('font-size', '16px');
        xLabel.textContent = 'Time';
        g.appendChild(xLabel);

        const yLabel = document.createElementNS('http://www.w3.org/2000/svg', 'text');
        yLabel.setAttribute('x', -plotH / 2); yLabel.setAttribute('y', -35);
        yLabel.setAttribute('fill', '#f5d990'); yLabel.setAttribute('text-anchor', 'middle');
        yLabel.setAttribute('transform', 'rotate(-90)');
        yLabel.setAttribute('font-size', '16px');
        yLabel.textContent = 'x(t)';
        g.appendChild(yLabel);

        const tMax = traj1[traj1.length - 1].t;
        const xScale = plotW / tMax;
        const yScale = plotH / 50;

        // Draw trajectories
        [{ data: traj1, color: '#61afef' }, { data: traj2, color: '#e06c75' }].forEach(({ data, color }) => {
            let path = '';
            data.forEach((pt, i) => {
                const px = pt.t * xScale;
                const py = plotH / 2 - pt.x * yScale;
                path += (i === 0 ? 'M' : 'L') + `${px},${py}`;
            });
            const curve = document.createElementNS('http://www.w3.org/2000/svg', 'path');
            curve.setAttribute('d', path);
            curve.setAttribute('stroke', color);
            curve.setAttribute('stroke-width', 1.5);
            curve.setAttribute('fill', 'none');
            g.appendChild(curve);
        });
    }

    // ==========================================
    // EULER STEP-BY-STEP INTEGRATION
    // ==========================================
    let eulerState = { x: 0, v: 15, t: 0 };
    let eulerHistory = [];
    const eulerG = 9.8;
    const eulerX0 = 0;
    const eulerV0 = 15;

    function initEuler() {
        eulerState = { x: eulerX0, v: eulerV0, t: 0 };
        eulerHistory = [{ t: 0, x: eulerX0, v: eulerV0 }];
        drawEulerPlot();
        updateEulerComputation(null);
    }

    function eulerStep() {
        const dt = parseFloat(document.getElementById('euler-dt')?.value || 0.2);
        document.getElementById('euler-dt-val').textContent = dt.toFixed(2);

        const n = eulerHistory.length - 1;
        const prev = eulerHistory[n];

        // Euler update
        let v_new = prev.v - eulerG * dt;
        let x_new = prev.x + prev.v * dt;
        const t_new = prev.t + dt;

        // Check for bounce (ball hits the floor)
        let bounced = false;
        if (x_new < 0) {
            x_new = -x_new * 0.8;  // Reflect with some energy loss
            v_new = -v_new * 0.8;  // Flip velocity with damping
            bounced = true;
        }

        eulerState = { x: x_new, v: v_new, t: t_new };
        eulerHistory.push({ t: t_new, x: x_new, v: v_new, bounced: bounced });

        drawEulerPlot();
        updateEulerComputation({ n, prev, dt, v_new, x_new, t_new, bounced });
    }

    function eulerReset() {
        initEuler();
    }

    function updateEulerComputation(stepData) {
        const container = document.getElementById('euler-computation');
        if (!container) return;

        if (!stepData) {
            container.innerHTML = `
                <div style="margin-bottom: 10px;"><strong>Initial conditions:</strong></div>
                <div>$x_0 = 0$ m</div>
                <div>$v_0 = 15$ m/s (upward)</div>
                <div>$g = 9.8$ m/s¬≤</div>
                <div style="margin-top: 15px; color: #888;">Click "Step" to begin...</div>
            `;
        } else {
            const { n, prev, dt, v_new, x_new, t_new, bounced } = stepData;
            let bounceMsg = '';
            if (bounced) {
                bounceMsg = `<div style="margin-top: 10px; color: #e06c75; font-weight: bold;">üèÄ BOUNCE! Hits the floor!</div>
                <div style="color: #e06c75; font-size: 0.9em;">$v \\rightarrow -0.8 \\cdot v$, $x \\rightarrow |x| \\cdot 0.8$</div>`;
            }
            container.innerHTML = `
                <div style="margin-bottom: 8px;"><strong>Step ${n} ‚Üí ${n + 1}:</strong> ($\\Delta t = ${dt.toFixed(2)}$s)</div>
                <div style="color: #e5c07b;">$v_{${n+1}} = v_{${n}} - g \\cdot \\Delta t$</div>
                <div style="margin-left: 20px;">$= ${prev.v.toFixed(2)} - 9.8 \\times ${dt.toFixed(2)}$</div>
                <div style="margin-left: 20px; color: var(--accent-cyan);">$= ${v_new.toFixed(2)}$ m/s</div>
                <div style="margin-top: 10px; color: #e5c07b;">$x_{${n+1}} = x_{${n}} + v_{${n}} \\cdot \\Delta t$</div>
                <div style="margin-left: 20px;">$= ${prev.x.toFixed(2)} + ${prev.v.toFixed(2)} \\times ${dt.toFixed(2)}$</div>
                <div style="margin-left: 20px; color: var(--accent-green);">$= ${x_new.toFixed(2)}$ m</div>
                ${bounceMsg}
                <div style="margin-top: 10px; color: #888;">$t = ${t_new.toFixed(2)}$ s</div>
            `;
        }
        // Re-render KaTeX
        if (typeof renderMathInElement !== 'undefined') {
            renderMathInElement(container, {
                delimiters: [
                    {left: '$$', right: '$$', display: true},
                    {left: '$', right: '$', display: false}
                ]
            });
        }
    }

    function drawEulerPlot() {
        const svg = document.getElementById('euler-plot');
        if (!svg) return;

        const width = 480, height = 300;
        const margin = { top: 20, right: 20, bottom: 40, left: 50 };
        const plotW = width - margin.left - margin.right;
        const plotH = height - margin.top - margin.bottom;

        svg.innerHTML = '';

        const g = document.createElementNS('http://www.w3.org/2000/svg', 'g');
        g.setAttribute('transform', `translate(${margin.left}, ${margin.top})`);
        svg.appendChild(g);

        // Calculate time range for the ball trajectory (time to return to ground)
        const tFlight = 2 * eulerV0 / eulerG; // Total flight time analytically
        const tMax = Math.max(tFlight * 1.1, eulerHistory[eulerHistory.length - 1]?.t || tFlight);
        const xMax = eulerV0 * eulerV0 / (2 * eulerG) * 1.3; // Max height + margin

        // Axes
        const xAxis = document.createElementNS('http://www.w3.org/2000/svg', 'line');
        xAxis.setAttribute('x1', 0); xAxis.setAttribute('y1', plotH);
        xAxis.setAttribute('x2', plotW); xAxis.setAttribute('y2', plotH);
        xAxis.setAttribute('stroke', '#666'); xAxis.setAttribute('stroke-width', 1.5);
        g.appendChild(xAxis);

        const yAxis = document.createElementNS('http://www.w3.org/2000/svg', 'line');
        yAxis.setAttribute('x1', 0); yAxis.setAttribute('y1', 0);
        yAxis.setAttribute('x2', 0); yAxis.setAttribute('y2', plotH);
        yAxis.setAttribute('stroke', '#666'); yAxis.setAttribute('stroke-width', 1.5);
        g.appendChild(yAxis);

        // Labels
        const xLabel = document.createElementNS('http://www.w3.org/2000/svg', 'text');
        xLabel.setAttribute('x', plotW / 2); xLabel.setAttribute('y', plotH + 30);
        xLabel.setAttribute('fill', '#7ee8f3'); xLabel.setAttribute('text-anchor', 'middle');
        xLabel.setAttribute('font-size', '16px');
        xLabel.textContent = 'Time (s)';
        g.appendChild(xLabel);

        const yLabel = document.createElementNS('http://www.w3.org/2000/svg', 'text');
        yLabel.setAttribute('x', -plotH / 2); yLabel.setAttribute('y', -35);
        yLabel.setAttribute('fill', '#f5d990'); yLabel.setAttribute('text-anchor', 'middle');
        yLabel.setAttribute('transform', 'rotate(-90)');
        yLabel.setAttribute('font-size', '16px');
        yLabel.textContent = 'Height x(t) (m)';
        g.appendChild(yLabel);

        // Draw analytical solution (dashed green line)
        let analyticalPath = '';
        const nPoints = 100;
        for (let i = 0; i <= nPoints; i++) {
            const t = (i / nPoints) * tMax;
            const x_analytical = eulerX0 + eulerV0 * t - 0.5 * eulerG * t * t;
            const px = (t / tMax) * plotW;
            const py = plotH - (Math.max(0, x_analytical) / xMax) * plotH;
            analyticalPath += (i === 0 ? 'M' : 'L') + `${px},${py}`;
        }
        const analyticalCurve = document.createElementNS('http://www.w3.org/2000/svg', 'path');
        analyticalCurve.setAttribute('d', analyticalPath);
        analyticalCurve.setAttribute('stroke', '#98c379');
        analyticalCurve.setAttribute('stroke-width', 2);
        analyticalCurve.setAttribute('stroke-dasharray', '8,4');
        analyticalCurve.setAttribute('fill', 'none');
        g.appendChild(analyticalCurve);

        // Draw numerical solution (blue dots and lines)
        if (eulerHistory.length > 1) {
            let numPath = '';
            eulerHistory.forEach((pt, i) => {
                const px = (pt.t / tMax) * plotW;
                const py = plotH - (Math.max(0, pt.x) / xMax) * plotH;
                numPath += (i === 0 ? 'M' : 'L') + `${px},${py}`;
            });
            const numCurve = document.createElementNS('http://www.w3.org/2000/svg', 'path');
            numCurve.setAttribute('d', numPath);
            numCurve.setAttribute('stroke', '#61afef');
            numCurve.setAttribute('stroke-width', 2);
            numCurve.setAttribute('fill', 'none');
            g.appendChild(numCurve);
        }

        // Draw points
        eulerHistory.forEach((pt, i) => {
            const px = (pt.t / tMax) * plotW;
            const py = plotH - (Math.max(0, pt.x) / xMax) * plotH;

            const dot = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
            dot.setAttribute('cx', px);
            dot.setAttribute('cy', py);
            dot.setAttribute('r', 6);
            dot.setAttribute('fill', '#61afef');
            dot.setAttribute('stroke', '#fff');
            dot.setAttribute('stroke-width', 1);
            g.appendChild(dot);

            // Label for point
            const label = document.createElementNS('http://www.w3.org/2000/svg', 'text');
            label.setAttribute('x', px);
            label.setAttribute('y', py - 10);
            label.setAttribute('fill', '#ccc');
            label.setAttribute('text-anchor', 'middle');
            label.setAttribute('font-size', '10px');
            label.textContent = i.toString();
            g.appendChild(label);
        });

        // Ground line
        const ground = document.createElementNS('http://www.w3.org/2000/svg', 'line');
        ground.setAttribute('x1', 0); ground.setAttribute('y1', plotH);
        ground.setAttribute('x2', plotW); ground.setAttribute('y2', plotH);
        ground.setAttribute('stroke', '#888'); ground.setAttribute('stroke-width', 2);
        ground.setAttribute('stroke-dasharray', '4,2');
        g.appendChild(ground);

        // Tick marks on axes
        for (let i = 0; i <= 4; i++) {
            const t = (i / 4) * tMax;
            const px = (t / tMax) * plotW;
            const tick = document.createElementNS('http://www.w3.org/2000/svg', 'line');
            tick.setAttribute('x1', px); tick.setAttribute('y1', plotH);
            tick.setAttribute('x2', px); tick.setAttribute('y2', plotH + 5);
            tick.setAttribute('stroke', '#888');
            g.appendChild(tick);

            const tickLabel = document.createElementNS('http://www.w3.org/2000/svg', 'text');
            tickLabel.setAttribute('x', px); tickLabel.setAttribute('y', plotH + 15);
            tickLabel.setAttribute('fill', '#888'); tickLabel.setAttribute('text-anchor', 'middle');
            tickLabel.setAttribute('font-size', '10px');
            tickLabel.textContent = t.toFixed(1);
            g.appendChild(tickLabel);
        }

        for (let i = 0; i <= 4; i++) {
            const x = (i / 4) * xMax;
            const py = plotH - (x / xMax) * plotH;
            const tick = document.createElementNS('http://www.w3.org/2000/svg', 'line');
            tick.setAttribute('x1', 0); tick.setAttribute('y1', py);
            tick.setAttribute('x2', -5); tick.setAttribute('y2', py);
            tick.setAttribute('stroke', '#888');
            g.appendChild(tick);

            const tickLabel = document.createElementNS('http://www.w3.org/2000/svg', 'text');
            tickLabel.setAttribute('x', -8); tickLabel.setAttribute('y', py + 3);
            tickLabel.setAttribute('fill', '#888'); tickLabel.setAttribute('text-anchor', 'end');
            tickLabel.setAttribute('font-size', '10px');
            tickLabel.textContent = x.toFixed(1);
            g.appendChild(tickLabel);
        }
    }

    // ==========================================
    // INITIALIZATION
    // ==========================================
    Reveal.on('slidechanged', event => {
        // Euler step-by-step
        if (event.currentSlide.querySelector('#euler-plot')) {
            initEuler();
        }

        // Hudson Bay data
        if (event.currentSlide.querySelector('#hudson-data-viz')) {
            drawHudsonData();
        }

        // Predator-prey fitting
        if (event.currentSlide.querySelector('#predprey-fit-viz')) {
            initPredPreyFit();
        }

        // Game of Life
        if (event.currentSlide.querySelector('#life-canvas')) {
            initLife();
        } else if (lifeAnimId) {
            lifePlaying = false;
            clearTimeout(lifeAnimId);
        }

        // Pendulum
        if (event.currentSlide.querySelector('#pendulum-viz')) {
            initPendulum();
        } else if (pendAnimId) {
            cancelAnimationFrame(pendAnimId);
        }

        // Phase flow
        if (event.currentSlide.querySelector('#phase-flow-viz')) {
            drawPhaseFlow();
        }

        // PDE Grid
        if (event.currentSlide.querySelector('#pde-grid-viz')) {
            initPDEGrid();
        }

        // CFL Demo
        if (event.currentSlide.querySelector('#cfl-demo-viz')) {
            initCFLDemo();
        }

        // Fluid
        if (event.currentSlide.querySelector('#fluid-canvas')) {
            initFluid();
        } else if (fluidAnimId) {
            cancelAnimationFrame(fluidAnimId);
        }

        // Lorenz
        if (event.currentSlide.querySelector('#lorenz-viz')) {
            initLorenz();
        } else if (lorenzAnimId) {
            cancelAnimationFrame(lorenzAnimId);
        }

        // Lorenz divergence (the accident)
        if (event.currentSlide.querySelector('#lorenz-diverge-viz')) {
            initLorenzDiverge();
        }

        // Lorenz sensitivity
        if (event.currentSlide.querySelector('#lorenz-sensitivity-viz')) {
            initLorenzSensitivity();
        }
    });

    // Slider listeners
    document.addEventListener('DOMContentLoaded', () => {
        document.getElementById('euler-dt')?.addEventListener('input', () => {
            document.getElementById('euler-dt-val').textContent = parseFloat(document.getElementById('euler-dt').value).toFixed(2);
        });
        // Predator-prey fitting sliders
        document.getElementById('pp-alpha')?.addEventListener('input', drawPredPreyFit);
        document.getElementById('pp-beta')?.addEventListener('input', drawPredPreyFit);
        document.getElementById('pp-delta')?.addEventListener('input', drawPredPreyFit);
        document.getElementById('pp-gamma')?.addEventListener('input', drawPredPreyFit);
        // Pendulum
        document.getElementById('pend-theta0')?.addEventListener('input', () => {
            if (pendAnimId) cancelAnimationFrame(pendAnimId);
            initPendulum();
        });
        // CFL slider
        document.getElementById('cfl-r')?.addEventListener('input', () => {
            document.getElementById('cfl-r-val').textContent = parseFloat(document.getElementById('cfl-r').value).toFixed(2);
        });
        // Fluid sliders
        document.getElementById('fluid-visc')?.addEventListener('input', () => {
            const val = parseFloat(document.getElementById('fluid-visc').value);
            document.getElementById('fluid-visc-val').textContent = val.toExponential(0);
        });
        document.getElementById('fluid-diff')?.addEventListener('input', () => {
            const val = parseFloat(document.getElementById('fluid-diff').value);
            document.getElementById('fluid-diff-val').textContent = val.toExponential(0);
        });
        // Lorenz sliders
        document.getElementById('lorenz-speed')?.addEventListener('input', () => {
            document.getElementById('lorenz-speed-val').textContent = document.getElementById('lorenz-speed').value;
        });
        document.getElementById('lorenz-trail')?.addEventListener('input', () => {
            document.getElementById('lorenz-trail-val').textContent = document.getElementById('lorenz-trail').value;
        });
        document.getElementById('lorenz-perturb')?.addEventListener('input', updateLorenzSensitivity);
    });
</script>
</body>
</html>
